{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"signal-client \u2014 Async Python framework for resilient Signal bots","text":"Async Signal bots, production-ready by default <p>Build fast on <code>signal-cli-rest-api</code> with typed helpers, resilient ingestion, and observability baked in. Community-driven; not the official Signal app.</p> Get started View API reference Resilience first     Backpressure, DLQ retries, and rate/circuit breakers keep handlers stable during bursts.    Typed context helpers     Replies, reactions, attachments, locks, and receipts all live on one ergonomic context.    Operations ready     Health + metrics servers, structured logging with PII redaction, and storage options (memory, SQLite, Redis)."},{"location":"#quick-start","title":"Quick start","text":"<p>Deploy a minimal ping bot. The annotations explain each step.</p> <pre><code>import asyncio\nfrom signal_client import SignalClient, command\n\n\n@command(\"!ping\")\nasync def ping(ctx):  # (1)\n    await ctx.reply_text(\"pong\")  # (2)\n\n\nasync def main():\n    bot = SignalClient()  # (3)\n    bot.register(ping)    # (4)\n    await bot.start()     # (5)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <ol> <li>Commands are declared with the <code>@command</code> decorator.</li> <li>Use typed helpers on <code>ctx</code> for replies, reactions, attachments, and receipts.</li> <li><code>SignalClient</code> wires ingestion, queueing, and backpressure for you.</li> <li>Register handlers before starting the client.</li> <li><code>start()</code> connects to <code>signal-cli-rest-api</code> over websocket + REST.</li> </ol> <p>Run it with your environment set: <code>poetry run python examples/ping_bot.py</code>.</p>"},{"location":"#message-flow","title":"Message flow","text":"<pre><code>flowchart TD\n    signal[Signal message] --&gt; rest[signal-cli-rest-api]\n    rest --&gt; ingest[signal-client websocket ingest]\n    ingest --&gt; pressure{Queue pressure?}\n    pressure -- yes --&gt; dlq[DLQ and retry]\n    pressure -- no --&gt; handler[Handler execution]\n    handler --&gt; reply[Reply / attachment / reaction]\n    handler --&gt; metrics[Metrics and logging]</code></pre>"},{"location":"#troubleshooting","title":"Troubleshooting","text":"<ul> <li>No replies? Confirm <code>SIGNAL_SERVICE_URL</code> matches your websocket host and the bot number is registered.</li> <li>Event loop closed errors? Ensure a single <code>asyncio.run</code> entrypoint and avoid running the script twice in the same shell session.</li> <li>Messages slow to drain? Lower <code>WORKER_SHARD_COUNT</code> or raise <code>QUEUE_SIZE</code> in constrained environments.</li> </ul>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Read Getting started for full setup and health checks.</li> <li>Try more Examples with annotated snippets pulled from the source.</li> <li>Explore Advanced usage for middleware, locks, and observability.</li> <li>Review Operations &amp; deployment before running in production.</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Three runnable samples you can copy, run, and extend. All assume the environment from Getting started is exported and <code>signal-cli-rest-api</code> is reachable.</p>"},{"location":"examples/#overview","title":"Overview","text":"Example What it shows Run command Ping bot Minimal handler + reply <code>poetry run python examples/ping_bot.py</code> Reminder bot Parsing + scheduling <code>poetry run python examples/reminder_bot.py</code> Webhook relay HTTP ingress \u2192 Signal send <code>poetry run python examples/webhook_relay.py</code>"},{"location":"examples/#ping-bot-minimal-sanity-check","title":"Ping bot \u2014 minimal sanity check","text":"<ul> <li>Source: <code>examples/ping_bot.py</code></li> <li>Behavior: replies <code>pong</code> to <code>!ping</code> while exercising websocket ingest + REST send.</li> <li>Run: <code>poetry run python examples/ping_bot.py</code></li> </ul> <pre><code>\"\"\"Minimal ping/pong bot to verify your Signal setup.\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\n\nfrom signal_client import Context, SignalClient, command\n\n\n@command(\"!ping\")\nasync def ping(ctx: Context) -&gt; None:\n    \"\"\"Reply with a basic pong.\"\"\"\n    await ctx.reply_text(\"pong\")  # (1)\n\n\nasync def main() -&gt; None:\n    \"\"\"Run the ping bot.\"\"\"\n    bot = SignalClient()  # (2)\n    bot.register(ping)  # (3)\n    await bot.start()  # (4)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <ol> <li>Reply with a single line of text to prove routing works.</li> <li>Instantiate the client (wires websocket ingest + backpressure).</li> <li>Register the handler before starting.</li> <li>Start the runtime; shutdown with Ctrl+C.</li> </ol>"},{"location":"examples/#reminder-bot-scheduling-work","title":"Reminder bot \u2014 scheduling work","text":"<ul> <li>Source: <code>examples/reminder_bot.py</code></li> <li>Behavior: <code>!remind &lt;seconds&gt; &lt;message&gt;</code> schedules a reminder back to the sender.</li> <li>Run: <code>poetry run python examples/reminder_bot.py</code></li> </ul> <pre><code>\"\"\"Schedule lightweight reminders from chat messages.\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\n\nfrom signal_client import Context, SignalClient, command\n\n_REQUIRED_PARTS = 3\n\n\n@command(\"!remind\")\nasync def remind(ctx: Context) -&gt; None:\n    \"\"\"Parse `!remind &lt;seconds&gt; &lt;message&gt;` and send the reminder later.\"\"\"\n    raw = ctx.message.message or \"\"  # (1)\n    parts = raw.split(maxsplit=2)\n    if len(parts) &lt; _REQUIRED_PARTS:\n        await ctx.reply_text(\"Usage: !remind &lt;seconds&gt; &lt;message&gt;\")\n        return\n\n    try:\n        delay = int(parts[1])\n    except ValueError:\n        await ctx.reply_text(\"Seconds must be an integer.\")\n        return\n\n    note = parts[2].strip()\n    if not note:\n        await ctx.reply_text(\"Please provide reminder text.\")\n        return\n\n    async def _send_reminder() -&gt; None:\n        await asyncio.sleep(delay)  # (2)\n        await ctx.send_text(f\"\u23f0 Reminder: {note}\")  # (3)\n\n    asyncio.create_task(_send_reminder())  # noqa: RUF006  # (4)\n    await ctx.reply_text(f\"Reminder scheduled in {delay} seconds.\")\n\n\nasync def main() -&gt; None:\n    \"\"\"Run the reminder bot.\"\"\"\n    bot = SignalClient()  # (5)\n    bot.register(remind)\n    await bot.start()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <ol> <li>Parse the incoming message content; give usage guidance when missing args.</li> <li>Sleep asynchronously for the requested delay.</li> <li>Send the reminder using the same context (reuses auth + routing).</li> <li>Fire-and-forget via <code>asyncio.create_task</code> to avoid blocking other commands.</li> <li>The same client wiring applies: register then start.</li> </ol>"},{"location":"examples/#webhook-relay-http-to-signal-bridge","title":"Webhook relay \u2014 HTTP to Signal bridge","text":"<ul> <li>Source: <code>examples/webhook_relay.py</code></li> <li>Behavior: tiny HTTP server on <code>127.0.0.1:8081</code> that accepts <code>{message, recipients}</code> JSON and relays to Signal.</li> <li>Run: <code>poetry run python examples/webhook_relay.py</code>, then POST with <code>curl</code> as shown in the file docstring.</li> </ul> <pre><code>r\"\"\"Accept JSON payloads over HTTP and relay them to Signal recipients.\n\nRequirements:\n- A running `signal-cli-rest-api` instance\n- Environment: SIGNAL_PHONE_NUMBER, SIGNAL_SERVICE_URL, SIGNAL_API_URL\n\nRun:\n    poetry run python examples/webhook_relay.py\nThen POST:\n    curl -X POST http://localhost:8081/relay \\\n      -H 'Content-Type: application/json' \\\n      -d '{\"recipients\": [\"+15551234567\"], \"message\": \"Hello from webhook relay\"}'\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport contextlib\nimport json\nimport signal\nfrom collections.abc import Iterable\n\nfrom aiohttp import ContentTypeError, web\n\nfrom signal_client.app import Application\nfrom signal_client.core.config import Settings\n\n\ndef _normalize_recipients(raw: object) -&gt; list[str]:\n    if isinstance(raw, str):\n        normalized = raw.strip()\n        return [normalized] if normalized else []\n    if isinstance(raw, Iterable):\n        recipients: list[str] = []\n        for item in raw:\n            text = str(item).strip()\n            if text:\n                recipients.append(text)\n        return recipients\n    return []\n\n\nasync def main() -&gt; None:\n    \"\"\"Start a small webhook server that relays messages to Signal.\"\"\"\n    settings = Settings.from_sources()  # (1)\n    application = Application(settings)\n    await application.initialize()  # (2)\n    if application.api_clients is None:\n        message = \"API clients failed to initialize\"\n        raise RuntimeError(message)\n\n    async def _health(_: web.Request) -&gt; web.Response:\n        return web.json_response({\"status\": \"ok\"})\n\n    async def _relay(request: web.Request) -&gt; web.Response:\n        try:\n            payload = await request.json()  # (3)\n        except (json.JSONDecodeError, ContentTypeError):\n            return web.json_response({\"error\": \"invalid json body\"}, status=400)\n\n        message = str(payload.get(\"message\") or \"Hello from webhook relay\")\n        recipients = _normalize_recipients(payload.get(\"recipients\"))\n        if not recipients:\n            recipients = [settings.phone_number]\n\n        send_payload = {\n            \"number\": settings.phone_number,\n            \"recipients\": recipients,\n            \"message\": message,\n        }\n        await application.api_clients.messages.send(send_payload)  # (4)\n        return web.json_response({\"status\": \"sent\", \"recipients\": recipients})\n\n    web_app = web.Application()\n    web_app.add_routes(\n        [\n            web.get(\"/health\", _health),\n            web.post(\"/relay\", _relay),\n        ]\n    )\n    runner = web.AppRunner(web_app)\n    await runner.setup()\n    site = web.TCPSite(runner, \"127.0.0.1\", 8081)\n    await site.start()  # (5)\n    print(\"Webhook relay listening on http://127.0.0.1:8081/relay\")\n\n    stop_event = asyncio.Event()\n\n    def _signal_stop() -&gt; None:\n        stop_event.set()\n\n    loop = asyncio.get_running_loop()\n    for sig in (signal.SIGINT, signal.SIGTERM):\n        with contextlib.suppress(NotImplementedError):\n            loop.add_signal_handler(sig, _signal_stop)\n\n    try:\n        await stop_event.wait()\n    finally:\n        await runner.cleanup()\n        await application.shutdown()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <ol> <li>Load settings from environment to keep secrets out of code.</li> <li>Initialize the application and API clients before binding routes.</li> <li>Validate JSON input and normalize recipients.</li> <li>Reuse the generated API clients to send outbound messages.</li> <li>Start the <code>aiohttp</code> server and leave it running until interrupted.</li> </ol>"},{"location":"examples/#how-to-try-an-example","title":"How to try an example","text":"<pre><code>flowchart LR\n    A[Set env vars] --&gt; B[Choose example]\n    B --&gt; C[Run poetry command]\n    C --&gt; D[Test via Signal or HTTP]\n    D --&gt; E[Watch logs + metrics]</code></pre>"},{"location":"examples/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Examples exit immediately: ensure environment variables are exported; the clients bail when config is missing.</li> <li>Webhook relay returns 400: send valid JSON with <code>message</code> and <code>recipients</code>; see the docstring curl example.</li> <li>Reminder bot never fires: confirm the delay is an integer and the process stays running (no container restarts).</li> </ul>"},{"location":"examples/#next-steps","title":"Next steps","text":"<ul> <li>Use the ping bot as a heartbeat in CI to validate credentials.</li> <li>Extend the reminder bot with persistent storage (see Advanced usage).</li> <li>Wrap the webhook relay with auth and TLS before exposing it beyond localhost.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":"<p>Spin up a minimal bot, verify connectivity, and learn the signals to watch.</p>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Signal phone number already registered with <code>signal-cli</code>.</li> <li>Running <code>bbernhard/signal-cli-rest-api</code> (websocket + REST) reachable from this host.</li> <li>Python 3.10+ with <code>poetry</code> or <code>pip</code> available.</li> <li>Export these environment variables before running:</li> </ul> <pre><code>export SIGNAL_PHONE_NUMBER=+15551234567\nexport SIGNAL_SERVICE_URL=http://localhost:8080\nexport SIGNAL_API_URL=http://localhost:8080\n</code></pre> <p>Private by default</p> <p>Keep <code>signal-cli-rest-api</code> on a private network or localhost. Do not expose it to the public internet.</p>"},{"location":"getting_started/#install","title":"Install","text":"Poetrypip <pre><code>poetry add signal_client\n</code></pre> <pre><code>python3 -m pip install signal-client\n</code></pre>"},{"location":"getting_started/#run-your-first-bot-runnable","title":"Run your first bot (runnable)","text":"<p>Create <code>examples/ping_bot.py</code> or reuse the existing file. The callouts show what matters.</p> <pre><code>import asyncio\nfrom signal_client import SignalClient, command\n\n\n@command(\"!ping\")\nasync def ping(ctx):  # (1)\n    await ctx.reply_text(\"pong\")  # (2)\n\n\nasync def main():\n    bot = SignalClient()  # (3)\n    bot.register(ping)    # (4)\n    await bot.start()     # (5)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <ol> <li>Commands are lightweight coroutines; decorators register triggers.</li> <li><code>ctx</code> exposes typed helpers for replies, reactions, attachments, and receipts.</li> <li><code>SignalClient</code> wires websocket ingest, queueing, and backpressure controls.</li> <li>Register handlers before starting the runtime.</li> <li><code>start()</code> connects to <code>signal-cli-rest-api</code> using your exported URLs.</li> </ol> <p>Run it: <code>poetry run python examples/ping_bot.py</code>, then send <code>!ping</code> from a contact the bot can reach.</p>"},{"location":"getting_started/#health-check-diagram","title":"Health check diagram","text":"<pre><code>sequenceDiagram\n    participant You\n    participant Bot as signal-client\n    participant API as signal-cli-rest-api\n    You-&gt;&gt;Bot: !ping\n    Bot-&gt;&gt;API: Websocket receive\n    Bot--&gt;&gt;Bot: Queue + worker pool\n    Bot-&gt;&gt;API: REST reply \"pong\"\n    API--&gt;&gt;You: Message delivered</code></pre>"},{"location":"getting_started/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>No websocket events: double-check <code>SIGNAL_SERVICE_URL</code> and that the bot number is registered on <code>signal-cli</code>.</li> <li>Replies hang: verify outbound REST at <code>SIGNAL_API_URL</code> is reachable and not blocked by a proxy/firewall.</li> <li>Unicode errors on Windows shells: ensure <code>.venv</code> encoding is UTF-8 or run via <code>poetry run python ...</code> inside a UTF-8 terminal.</li> </ul>"},{"location":"getting_started/#next-steps","title":"Next steps","text":"<ul> <li>Explore Examples for runnable bots with annotated snippets.</li> <li>Layer in middleware and locks in Advanced usage.</li> <li>Prepare for production with Operations &amp; deployment.</li> </ul>"},{"location":"changelog/","title":"Release notes","text":"<p>Stay current with signal-client updates, releases, and notable docs changes. Subscribe via RSS/Atom using the feed link in the header.</p>"},{"location":"changelog/#at-a-glance","title":"At a glance","text":"<ul> <li>Each entry lives under <code>docs/changelog/YYYY-MM-DD-*.md</code> via the blog plugin.</li> <li>Release automation updates this list; manual posts are welcome for docs and ops changes.</li> <li>CTA: read Release &amp; publishing before shipping a new version.</li> </ul> <pre><code>flowchart LR\n    A[Change lands] --&gt; B[Write changelog post]\n    B --&gt; C[mkdocs build]\n    C --&gt; D[Publish via mike/gh-deploy]\n    D --&gt; E[Feed updates]</code></pre>"},{"location":"changelog/#add-a-new-post-runnable","title":"Add a new post (runnable)","text":"<pre><code>poetry run mike deploy --update-aliases &lt;version&gt; latest\npoetry run mkdocs new docs/changelog/$(date +%Y-%m-%d)-note.md\n</code></pre> <p>Fill the new file with front matter (<code>title</code>, <code>date</code>) and a short summary of what changed.</p>"},{"location":"changelog/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Feed not updating: ensure <code>site_url</code> is set in <code>mkdocs.yml</code> and rerun <code>poetry run mkdocs build --strict</code>.</li> <li>Broken links: fix via the redirects plugin (<code>redirects</code> section in <code>mkdocs.yml</code>) and rebuild.</li> </ul>"},{"location":"changelog/#next-steps","title":"Next steps","text":"<ul> <li>Announce major changes in chat/Slack with a link to the latest post.</li> <li>Keep guides and examples in sync with any API surface changes noted here.</li> </ul>"},{"location":"changelog/2025-01-05-initial-docs/","title":"Initial docs stack plan","text":"<p>We are rolling out the new MkDocs + Material documentation stack with PR previews, quality gates, and versioned publishing through <code>mike</code>. This post tracks the initial enablement work and migration guide for contributors.</p>","tags":["docs","mkdocs","release"]},{"location":"components/playground/","title":"Components playground","text":"<p>Use this page to preview the authoring building blocks before committing them to guides.</p>"},{"location":"components/playground/#badges-macros","title":"Badges &amp; macros","text":"<ul> <li>Inline badge: Beta</li> <li>Experimental badge: Experimental</li> <li>CTA macro: Open API</li> </ul>"},{"location":"components/playground/#admonitions","title":"Admonitions","text":"<p>PII redaction</p> <p>Incoming messages are redacted by default. Override with caution.</p> <p>Backpressure</p> <p>If the inbound queue exceeds the high watermark, new messages are deferred to protect upstream signal-cli.</p>"},{"location":"components/playground/#tabs","title":"Tabs","text":"LocalDocker <pre><code>poetry run mkdocs serve\n</code></pre> <pre><code>docker run -it --rm -p 8000:8000 -v $PWD:/docs squidfunk/mkdocs-material\n</code></pre>"},{"location":"components/playground/#cards-grids","title":"Cards &amp; grids","text":":material-rocket: DeploySee [Operations &amp; deployment](../guides/production_deployment.md) :material-code-tags: API referenceJump to [API reference](../reference/api.md) :material-alert-decagram: Release guardrailsFollow [Release &amp; publishing](../guides/release.md)"},{"location":"components/playground/#annotated-code","title":"Annotated code","text":"<pre><code>\"\"\"Minimal ping/pong bot to verify your Signal setup.\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\n\nfrom signal_client import Context, SignalClient, command\n\n\n@command(\"!ping\")\nasync def ping(ctx: Context) -&gt; None:\n    \"\"\"Reply with a basic pong.\"\"\"\n    await ctx.reply_text(\"pong\")  # (1)\n\n\nasync def main() -&gt; None:\n    \"\"\"Run the ping bot.\"\"\"\n    bot = SignalClient()  # (2)\n    bot.register(ping)  # (3)\n    await bot.start()  # (4)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"components/playground/#diagrams","title":"Diagrams","text":"<pre><code>flowchart TD\n    A[Signal message] --&gt; B[signal-cli-rest-api]\n    B --&gt; C[signal-client ingestion]\n    C --&gt; D{Backpressure?}\n    D -- yes --&gt; E[Delay + retry]\n    D -- no --&gt; F[Dispatch handler]\n    F --&gt; G[Send reply/attachment]</code></pre>"},{"location":"contributing/docs-authoring/","title":"Docs authoring guide","text":"<p>Tagline: Async Python framework for resilient Signal bots (community SDK, not the official Signal app).</p> <p>Use this guide when editing docs so pages stay consistent and on-brand.</p>"},{"location":"contributing/docs-authoring/#brand-voice","title":"Brand voice","text":"<ul> <li>Audience: Python developers building Signal bots on <code>signal-cli-rest-api</code>.</li> <li>Positioning: community, async-first bot runtime with resilient ingestion and typed helpers; not an official Signal client.</li> <li>Tone: practical, concise, confident. Lead with the problem solved; avoid hype.</li> <li>Word bank: async, resilient, backpressure, typed, bot runtime, Signal bot, open source, production-minded.</li> <li>Avoid: \u201cofficial Signal client,\u201d \u201csealed/enterprise,\u201d \u201cmagic,\u201d \u201cwebhook-only,\u201d \u201cunsupported hacks.\u201d</li> </ul>"},{"location":"contributing/docs-authoring/#page-structure-template","title":"Page structure template","text":"<p>Every first-level page should include: front matter (<code>title</code>, <code>description</code>), a lead/CTA, prerequisites (if applicable), at least one runnable snippet, a diagram for flows, troubleshooting, and \u201cNext steps\u201d. Use Overview and Getting started as references.</p>"},{"location":"contributing/docs-authoring/#macros-snippets","title":"Macros &amp; snippets","text":"<ul> <li>Buttons: <code>&lt;a class=\"md-button md-button--primary\" href=\"getting_started.md\"&gt;Get started&lt;/a&gt;</code> renders a Material-styled button.</li> <li>Badges: <code>&lt;span class='badge badge--beta'&gt;Beta&lt;/span&gt;</code> or <code>&lt;span class='badge badge--experimental'&gt;Experimental&lt;/span&gt;</code>.</li> <li>Env block: reuse <code>bash export SIGNAL_PHONE_NUMBER=+15551234567 export SIGNAL_SERVICE_URL=http://localhost:8080 export SIGNAL_API_URL=http://localhost:8080</code> instead of duplicating exports.</li> <li>Pull code from the repo using <code>pymdownx.snippets</code>:</li> </ul> <p><pre><code>```python\n\"\"\"Minimal ping/pong bot to verify your Signal setup.\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\n\nfrom signal_client import Context, SignalClient, command\n\n\n@command(\"!ping\")\nasync def ping(ctx: Context) -&gt; None:\n    \"\"\"Reply with a basic pong.\"\"\"\n    await ctx.reply_text(\"pong\")  # (1)\n\n\nasync def main() -&gt; None:\n    \"\"\"Run the ping bot.\"\"\"\n    bot = SignalClient()  # (2)\n    bot.register(ping)  # (3)\n    await bot.start()  # (4)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>   ``` - See live output in Components playground.</p>"},{"location":"contributing/docs-authoring/#annotated-code","title":"Annotated code","text":"<p>Describe important steps with a short bullet list aligned to each snippet instead of relying on automatic callouts:</p> <pre><code>@command(\"!ping\")\nasync def ping(ctx):\n    await ctx.reply_text(\"pong\")\n</code></pre> <ul> <li>Summaries live immediately after the code block.</li> <li>Keep explanations concise and focused on what each highlighted action does.</li> </ul>"},{"location":"contributing/docs-authoring/#tabs-cards-and-grids","title":"Tabs, cards, and grids","text":"<ul> <li>Tabs: use <code>=== \"Tab\"</code> blocks for alternative flows (e.g., pip vs Poetry).</li> <li>Cards/grids: wrap content in <code>&lt;div class=\"brand-grid\"&gt;</code> + <code>&lt;div class=\"brand-card\"&gt;</code> for a consistent layout.</li> </ul>"},{"location":"contributing/docs-authoring/#media-and-diagrams","title":"Media and diagrams","text":"<ul> <li>Diagrams: prefer Mermaid fenced blocks (<code>```mermaid</code>). Keep flows short and legible.</li> <li>Images: Markdown images gain a lightbox automatically; add <code>data-gallery=\"assets\"</code> when grouping screenshots.</li> <li>Icons: use Material icons (<code>:material-rocket:</code>) sparingly to anchor cards.</li> </ul>"},{"location":"contributing/docs-authoring/#cross-linking","title":"Cross-linking","text":"<ul> <li>Use relative links; <code>autorefs</code> resolves headings automatically. Example: <code>[Advanced usage](../guides/advanced_usage.md)</code>.</li> <li>When moving content, add redirects in <code>mkdocs.yml</code> under <code>redirect_maps</code>.</li> </ul>"},{"location":"contributing/docs-authoring/#voice-checks","title":"Voice checks","text":"<ul> <li>Mention the community/non-official disclaimer on landing pages and marketing copy.</li> <li>Lead with capability + safety: backpressure, DLQ, redaction.</li> <li>Invite contributions with clear next actions (issues, PRs, docs edits).</li> </ul>"},{"location":"contributing/docs-authoring/#playground","title":"Playground","text":"<p>Preview all components on Components playground before rolling them into guides.</p>"},{"location":"contributing/docs-ops/","title":"Docs ops runbook","text":""},{"location":"contributing/docs-ops/#versions-and-plugins","title":"Versions and plugins","text":"<ul> <li>MkDocs: 1.6.1 (strict mode on).</li> <li>Material: 9.7.x (maintenance channel; minimal overrides for easy theme swap).</li> <li>Versioning: <code>mike</code> with <code>latest</code> alias; tags promote versioned docs.</li> <li>Core plugins: awesome-pages, section-index, mkdocstrings[python], mike, i18n (default en), redirects, git-revision-date-localized, minify, mermaid2, glightbox, Material blog/feed.</li> <li>Governance: propose new plugins via PR, include maintenance status and perf impact; pin versions in <code>pyproject.toml</code>.</li> </ul>"},{"location":"contributing/docs-ops/#commands","title":"Commands","text":"<ul> <li>Local preview: <code>poetry run mkdocs serve</code></li> <li>Strict build: <code>poetry run mkdocs build</code></li> <li>Versioned publish (dry run): <code>poetry run mike deploy --update-aliases 0.1.0 latest --push --remote origin --dry-run</code></li> <li>Promote tag: <code>poetry run mike deploy --update-aliases $VERSION latest --push --remote origin</code></li> <li>Set default: <code>poetry run mike set-default latest --push --remote origin</code></li> </ul>"},{"location":"contributing/docs-ops/#quality-gates-ci","title":"Quality gates (CI)","text":"<ul> <li>Broken references: <code>mkdocs build --strict</code></li> <li>Links: <code>lycheeverse/lychee-action</code> on built <code>site/</code></li> <li>Markdown style: <code>pymarkdown scan</code></li> <li>Spell check: <code>codespell</code> with project dictionary</li> </ul>"},{"location":"contributing/docs-ops/#previews-and-deploys","title":"Previews and deploys","text":"<ul> <li>PRs: build docs, run quality checks, upload <code>site</code> as artifact, and (when permitted) publish a GitHub Pages preview.</li> <li>Default branch: build + mike deploy <code>latest</code> to <code>gh-pages</code>.</li> <li>Tags: promote tag version with <code>mike</code> and keep <code>latest</code> alias in sync.</li> <li>Rollback: redeploy previous artifact/commit via workflow input <code>rollback_ref</code>.</li> </ul>"},{"location":"contributing/docs-ops/#maintenance","title":"Maintenance","text":"<ul> <li>Refresh dependencies quarterly or when security advisories land.</li> <li>If Material support degrades, evaluate Zensical or vanilla MkDocs theme with existing palette and icons; keep custom CSS minimal to ease the swap.</li> <li>Periodically audit redirects and remove stale mappings.</li> </ul>"},{"location":"guides/advanced_usage/","title":"Advanced usage","text":"<p>Build richer bots with structured routing, middleware, backpressure tuning, and observability hooks.</p>"},{"location":"guides/advanced_usage/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have completed Getting started and can run the ping bot.</li> <li>Environment variables from the quick start are already exported.</li> <li>Familiarity with async/await and dependency installation via Poetry.</li> </ul>"},{"location":"guides/advanced_usage/#routing-patterns","title":"Routing patterns","text":"<pre><code>from signal_client import SignalClient, command\n\n\nbot = SignalClient()\n\n\n@command(r\"^!echo\\s+(.+)$\", case_sensitive=False)\nasync def echo(ctx):  # (1)\n    await ctx.reply_text(ctx.message.message or \"\")\n\n\n@command(\"!admins\", whitelisted=[\"+15551234567\"])\nasync def admins_only(ctx):  # (2)\n    await ctx.reply_text(\"Admins can run operational commands here.\")\n\n\nbot.register(echo)\nbot.register(admins_only)\n</code></pre> <ol> <li> <p>Regex routing keeps triggers flexible; default match is case-insensitive.</p> </li> <li> <p>Use <code>whitelisted</code> to limit who can execute sensitive handlers.</p> </li> </ol>"},{"location":"guides/advanced_usage/#middleware-with-structured-logging-runnable","title":"Middleware with structured logging (runnable)","text":"<pre><code>from collections.abc import Awaitable, Callable\nfrom signal_client import Context, SignalClient\n\n\nclient = SignalClient()\n\n\nasync def log_middleware(\n    ctx: Context, next_handler: Callable[[Context], Awaitable[None]]\n) -&gt; None:\n    ctx.logger.info(\"handling\", message=ctx.message.message)  # (1)\n    await next_handler(ctx)  # (2)\n    ctx.logger.info(\"done\", source=ctx.message.source)  # (3)\n\n\nclient.use(log_middleware)\n</code></pre> <ol> <li> <p>Use the built-in structured logger (supports redaction).</p> </li> <li> <p>Call the <code>next_handler</code> to continue the chain; middleware order matters.</p> </li> <li> <p>Record completion with context-rich metadata.</p> </li> </ol>"},{"location":"guides/advanced_usage/#resiliency-controls","title":"Resiliency controls","text":"<ul> <li>Queue &amp; workers: tune <code>WORKER_POOL_SIZE</code>, <code>WORKER_SHARD_COUNT</code>, and <code>QUEUE_SIZE</code> for throughput. Lower values reduce memory but increase latency.</li> <li>Durable ingest: set <code>DURABLE_QUEUE_ENABLED=true</code> to persist inbound messages (SQLite or Redis per <code>STORAGE_TYPE</code>).</li> <li>Dead Letter Queue: <code>DLQ_MAX_RETRIES</code> controls retries before parking a failed message.</li> <li>Rate limiting &amp; circuit breaking: configure <code>RATE_LIMIT</code> and <code>CIRCUIT_BREAKER_*</code> to protect <code>signal-cli-rest-api</code> during spikes.</li> </ul> <pre><code>flowchart LR\n    Ingest[Websocket ingest] --&gt; Queue[Queue + backpressure]\n    Queue --&gt; Workers[Worker pool]\n    Workers --&gt;|success| Done[Handlers complete]\n    Workers --&gt;|failure| Retry[Retry with jitter]\n    Retry --&gt;|exceeds limit| DLQ</code></pre>"},{"location":"guides/advanced_usage/#context-helpers-quick-sheet","title":"Context helpers (quick sheet)","text":"<ul> <li>Replies: <code>await ctx.reply_text(\"pong\")</code>, <code>await ctx.send_markdown(\"*hi*\")</code>.</li> <li>Attachments: <code>async with ctx.download_attachments() as files: ...</code>.</li> <li>Reactions/receipts: <code>await ctx.react(\"\ud83d\udc4d\")</code>, <code>await ctx.send_receipt(ctx.message.timestamp)</code>.</li> <li>Locks: <code>async with ctx.lock(\"resource-id\"):</code> when Redis storage is enabled.</li> <li>Typing indicators: <code>await ctx.show_typing()</code> / <code>await ctx.hide_typing()</code>.</li> </ul>"},{"location":"guides/advanced_usage/#observability","title":"Observability","text":"<pre><code>from signal_client.observability.health_server import start_health_server\nfrom signal_client.observability.metrics_server import start_metrics_server\n\n\napp = client.app\nawait app.initialize()\nawait start_health_server(app, port=8082)   # (1)\nawait start_metrics_server(port=8000)       # (2)\n</code></pre> <ol> <li> <p>Health endpoints expose <code>/live</code>, <code>/ready</code>, and <code>/dlq</code> for probes.</p> </li> <li> <p>Metrics server publishes Prometheus counters/gauges for queues and handlers.</p> </li> </ol>"},{"location":"guides/advanced_usage/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Handlers run twice: ensure each command decorator is applied once and the handler is registered a single time.</li> <li>Locks not acquired: confirm <code>STORAGE_TYPE=redis</code> and Redis credentials are reachable; locks are disabled for memory/SQLite modes.</li> <li>DLQ fills up: inspect failing payloads, lower <code>DLQ_MAX_RETRIES</code>, and add guardrails in middleware to reject unsupported commands early.</li> </ul>"},{"location":"guides/advanced_usage/#next-steps","title":"Next steps","text":"<ul> <li>Wire these patterns into the Examples.</li> <li>See Operations &amp; deployment for environment tuning and process supervision.</li> <li>Map APIs in Reference to handlers for deeper customization.</li> </ul>"},{"location":"guides/production_deployment/","title":"Operations &amp; deployment","text":"<p>Guide for running signal-client alongside <code>signal-cli-rest-api</code> in production.</p>"},{"location":"guides/production_deployment/#prerequisites","title":"Prerequisites","text":"<ul> <li>A healthy <code>signal-cli-rest-api</code> reachable on your private network.</li> <li>Environment variables exported (or provided via a secrets manager).</li> <li>Process manager available (systemd, supervisord, container runtime).</li> </ul>"},{"location":"guides/production_deployment/#runtime-shape","title":"Runtime shape","text":"<pre><code>flowchart LR\n    A[signal-cli-rest-api] --&gt; B[signal-client websocket ingest]\n    B --&gt; C[Queue + backpressure]\n    C --&gt; D[Worker pool]\n    D --&gt;|success| E[Handlers]\n    D --&gt;|failure| F[Retry + DLQ]\n    E --&gt; G[REST send]\n    E --&gt; H[Metrics + health]</code></pre>"},{"location":"guides/production_deployment/#environment","title":"Environment","text":"Variable Purpose Typical value <code>SIGNAL_PHONE_NUMBER</code> Bot identity <code>+15551234567</code> <code>SIGNAL_SERVICE_URL</code> Websocket host <code>http://localhost:8080</code> <code>SIGNAL_API_URL</code> REST host <code>http://localhost:8080</code> <code>STORAGE_TYPE</code> <code>memory</code> | <code>sqlite</code> | <code>redis</code> <code>sqlite</code> for single node, <code>redis</code> for HA <code>DURABLE_QUEUE_ENABLED</code> Persist inbound queue <code>true</code> in prod <code>DLQ_MAX_RETRIES</code> Retries before parking <code>5</code> <code>RATE_LIMIT</code> Max msgs/min <code>50</code> (tune per cluster) <code>CIRCUIT_BREAKER_*</code> Protect upstream REST See defaults; lower for unstable links"},{"location":"guides/production_deployment/#deployment-patterns","title":"Deployment patterns","text":"<ul> <li>SQLite for single-node durability: set <code>STORAGE_TYPE=sqlite</code> and optionally <code>SQLITE_DATABASE=signal_client.db</code>.</li> <li>Redis for distributed locks/queues: set <code>STORAGE_TYPE=redis</code>, <code>REDIS_HOST</code>, and <code>REDIS_PORT</code>; enables <code>ctx.lock</code> and shared ingestion across processes.</li> <li>Backpressure tuning: adjust <code>QUEUE_SIZE</code>, <code>WORKER_POOL_SIZE</code>, and <code>WORKER_SHARD_COUNT</code> to balance latency vs. memory.</li> <li>Graceful shutdown: send SIGTERM/SIGINT; the client drains the queue, stops workers, and closes websocket + HTTP sessions.</li> </ul>"},{"location":"guides/production_deployment/#health-and-metrics-runnable","title":"Health and metrics (runnable)","text":"<pre><code>from signal_client.observability.health_server import start_health_server\nfrom signal_client.observability.metrics_server import start_metrics_server\nfrom signal_client import SignalClient\n\nclient = SignalClient()\nawait client.start()\nawait start_health_server(client.app, port=8082)  # (1)\nawait start_metrics_server(port=8000)             # (2)\n</code></pre> <ol> <li>Exposes <code>/live</code>, <code>/ready</code>, and <code>/dlq</code> for probes.</li> <li>Publishes Prometheus metrics for queue depth, websocket status, and handler timings.</li> </ol>"},{"location":"guides/production_deployment/#security-and-hardening","title":"Security and hardening","text":"<ul> <li>Keep <code>signal-cli-rest-api</code> off the public internet; front it with a firewall or private network.</li> <li>Store secrets outside the repo (env vars, secret manager, or injected files with restricted permissions).</li> <li>Enable log redaction (<code>LOG_REDACTION_ENABLED=true</code>) so PII does not leak to logs.</li> <li>Rotate the Signal phone number token and REST auth tokens regularly; store them in CI/CD secrets.</li> </ul>"},{"location":"guides/production_deployment/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Health endpoints timeout: confirm the health server port is open on localhost and not blocked by SELinux/AppArmor.</li> <li>Redis locks never release: check <code>LOCK_TTL_SECONDS</code>; ensure system clocks are in sync (NTP) across nodes.</li> <li>High CPU on bursts: lower <code>WORKER_SHARD_COUNT</code> or raise <code>QUEUE_SIZE</code>; verify DLQ volume for poisoned messages.</li> </ul>"},{"location":"guides/production_deployment/#next-steps","title":"Next steps","text":"<ul> <li>See the Release &amp; publishing guide before shipping a new version.</li> <li>Add dashboards that scrape the metrics endpoint; alert on queue depth and DLQ growth.</li> <li>Run the Examples in the same environment to validate connectivity.</li> </ul>"},{"location":"guides/release/","title":"Release &amp; publishing","text":"<p>Ship new versions with confidence using this checklist.</p>"},{"location":"guides/release/#prerequisites","title":"Prerequisites","text":"<ul> <li>CI is green on <code>main</code>.</li> <li>You can publish to PyPI and GitHub Releases (tokens configured in CI secrets).</li> <li>Docs build locally with <code>poetry run mkdocs build --strict</code>.</li> </ul>"},{"location":"guides/release/#quality-gates-runnable","title":"Quality gates (runnable)","text":"<pre><code>poetry check\npoetry run ruff check .\npoetry run mypy signal_client tools\npoetry run pytest\npoetry run mkdocs build --strict\n</code></pre>"},{"location":"guides/release/#packaging-verification","title":"Packaging &amp; verification","text":"<ul> <li>Build artifacts: <code>poetry build</code> (wheel + sdist in <code>dist/</code>).</li> <li>Sanity check the wheel: <code>python -m pip install dist/signal_client-&lt;version&gt;-py3-none-any.whl</code> in a clean venv, then run <code>poetry run python examples/ping_bot.py</code> with env vars set.</li> <li>Tag releases with semantic versioning; the README links to https://cornellsh.github.io/signal-client/.</li> </ul>"},{"location":"guides/release/#semantic-release-automation","title":"Semantic release automation","text":"<pre><code>poetry run semantic-release version  # bumps version + changelog\npoetry run semantic-release publish  # builds + uploads to PyPI/releases\n</code></pre>"},{"location":"guides/release/#docs-publishing","title":"Docs publishing","text":"<ul> <li>Validate: <code>poetry run mkdocs build --strict</code></li> <li>Publish to GitHub Pages (if configured): <code>poetry run mkdocs gh-deploy --clean</code></li> <li>Versions via <code>mike</code>: <code>poetry run mike deploy --update-aliases &lt;version&gt; latest</code> then <code>poetry run mike set-default latest</code></li> </ul> <pre><code>flowchart LR\n    A[Quality gates] --&gt; B[semantic-release version]\n    B --&gt; C[semantic-release publish]\n    C --&gt; D[Docs build]\n    D --&gt; E[Pages deploy / mike deploy]</code></pre>"},{"location":"guides/release/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Release fails on PyPI upload: ensure credentials are present and not scoped to testpypi; retry after refreshing the token.</li> <li>Docs links break after deploy: run <code>poetry run mkdocs build --strict</code> locally to spot missing references; check redirects in <code>mkdocs.yml</code>.</li> <li>Wheel missing files: confirm <code>packages = [{include = \"signal_client\"}]</code> and that data files are included if added.</li> </ul>"},{"location":"guides/release/#next-steps","title":"Next steps","text":"<ul> <li>Announce in the changelog (<code>docs/changelog/</code> via the blog plugin).</li> <li>Update sample bots if API signatures changed.</li> <li>Archive the change set with <code>openspec archive</code> when the release is deployed.</li> </ul>"},{"location":"reference/api/","title":"API reference","text":"<p>Core public surface for building Signal bots. See Getting started for setup and Advanced usage for patterns.</p>"},{"location":"reference/api/#quick-usage","title":"Quick usage","text":"<pre><code>from signal_client import SignalClient, command\n\n\n@command(\"!ping\")\nasync def ping(ctx):\n    await ctx.reply_text(\"pong\")\n\n\nclient = SignalClient()\nclient.register(ping)\nawait client.start()\n</code></pre> <pre><code>sequenceDiagram\n    participant Bot\n    participant API as signal-cli-rest-api\n    Bot-&gt;&gt;API: subscribe websocket\n    API--&gt;&gt;Bot: message event\n    Bot--&gt;&gt;Bot: handler via @command\n    Bot-&gt;&gt;API: REST reply</code></pre>"},{"location":"reference/api/#runtime","title":"Runtime","text":"<p>The main class for interacting with the Signal API and processing messages.</p> <p>This class orchestrates the various components of the signal-client, including API clients, message listeners, and worker pools.</p> Source code in <code>signal_client/app/bot.py</code> <pre><code>class SignalClient:\n    \"\"\"The main class for interacting with the Signal API and processing messages.\n\n    This class orchestrates the various components of the signal-client,\n    including API clients, message listeners, and worker pools.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: dict | None = None,\n        app: Application | None = None,\n        header_provider: HeaderProvider | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the SignalClient.\n\n        Args:\n            config: A dictionary of configuration overrides.\n            app: An optional pre-initialized Application instance.\n            header_provider: An optional callable or object that provides\n                             additional HTTP headers for API requests.\n\n        \"\"\"\n        check_supported_versions()\n        settings = Settings.from_sources(config=config)\n\n        ensure_structlog_configured(redaction_enabled=settings.log_redaction_enabled)\n        self.app = app or Application(settings, header_provider=header_provider)\n        self.settings = settings\n        self._commands: list[Command] = []\n        self._registered_command_ids: set[int] = set()\n        self._middleware: list[\n            Callable[[Context, Callable[[Context], Awaitable[None]]], Awaitable[None]]\n        ] = []\n\n    def register(self, command: Command) -&gt; None:\n        \"\"\"Register a new command with the client.\n\n        Registered commands will be executed when matching incoming messages.\n\n        Args:\n            command: The Command instance to register.\n\n        \"\"\"\n        self._commands.append(command)\n        self._register_with_worker_pool(command)\n\n    def use(\n        self,\n        middleware: Callable[\n            [Context, Callable[[Context], Awaitable[None]]], Awaitable[None]\n        ],\n    ) -&gt; None:\n        \"\"\"Register middleware to wrap command execution.\n\n        Middleware functions are called before command execution and can\n        modify the context or prevent command execution.\n\n        Args:\n            middleware: The middleware callable to register.\n\n        \"\"\"\n        if middleware in self._middleware:\n            return\n        self._middleware.append(middleware)\n        if self.app.worker_pool is not None:\n            self.app.worker_pool.register_middleware(middleware)\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Asynchronous context manager entry.\"\"\"\n        await self.app.initialize()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc: BaseException | None,\n        tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Asynchronous context manager exit.\n\n        Ensures proper shutdown of the client.\n        \"\"\"\n        await self.shutdown()\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the SignalClient, including message listening and worker processing.\n\n        This method will block indefinitely until the client is shut down.\n        \"\"\"\n        await self.app.initialize()\n        if self.app.worker_pool is None or self.app.message_service is None:\n            message = \"Runtime not initialized. Call await app.initialize() first.\"\n            raise RuntimeError(message)\n        worker_pool = self.app.worker_pool\n        message_service = self.app.message_service\n\n        for command in self._commands:\n            self._register_with_worker_pool(command)\n\n        for middleware in self._middleware:\n            worker_pool.register_middleware(middleware)\n\n        worker_pool.start()\n\n        try:\n            await asyncio.gather(\n                message_service.listen(),\n                worker_pool.join(),\n            )\n        finally:\n            await self.shutdown()\n\n    async def shutdown(self) -&gt; None:\n        \"\"\"Shut down the SignalClient gracefully.\n\n        This involves closing the websocket, waiting for queues to empty,\n        stopping workers, and closing the aiohttp session.\n        \"\"\"\n        # 1. Stop accepting new messages\n        if self.app.websocket_client is not None:\n            await self.app.websocket_client.close()\n\n        # 2. Wait for the queue to be empty\n        if self.app.queue is not None:\n            await self.app.queue.join()\n\n        # 3. Stop the workers\n        if self.app.worker_pool is not None:\n            self.app.worker_pool.stop()\n            await self.app.worker_pool.join()\n\n        # 4. Close the session and shutdown resources\n        if self.app.session is not None:\n            await self.app.session.close()\n        close_storage = getattr(self.app.storage, \"close\", None)\n        if close_storage is not None:\n            await close_storage()\n\n    def _register_with_worker_pool(self, command: Command) -&gt; None:\n        \"\"\"Register a command with the worker pool if not already present.\n\n        Args:\n            command: The command to register.\n\n        \"\"\"\n        if id(command) in self._registered_command_ids:\n            return\n\n        if self.app.worker_pool is None:\n            return\n\n        self.app.worker_pool.register(command)\n        self._registered_command_ids.add(id(command))\n\n    @property\n    def queue(self) -&gt; asyncio.Queue[QueuedMessage]:\n        \"\"\"Get the message queue.\n\n        Raises:\n            RuntimeError: If the application is not initialized.\n\n        Returns:\n            The asyncio.Queue for messages.\n\n        \"\"\"\n        if self.app.queue is None:\n            message = \"Runtime not initialized. Call await app.initialize() first.\"\n            raise RuntimeError(message)\n        return self.app.queue\n\n    @property\n    def worker_pool(self) -&gt; WorkerPool:\n        \"\"\"Get the worker pool.\n\n        Raises:\n            RuntimeError: If the application is not initialized.\n\n        Returns:\n            The WorkerPool instance.\n\n        \"\"\"\n        if self.app.worker_pool is None:\n            message = \"Runtime not initialized. Call await app.initialize() first.\"\n            raise RuntimeError(message)\n        return self.app.worker_pool\n\n    @property\n    def api_clients(self) -&gt; APIClients:\n        \"\"\"Get the API clients.\n\n        Raises:\n            RuntimeError: If the application is not initialized.\n\n        Returns:\n            The APIClients instance.\n\n        \"\"\"\n        if self.app.api_clients is None:\n            message = \"Runtime not initialized. Call await app.initialize() first.\"\n            raise RuntimeError(message)\n        return self.app.api_clients\n\n    @property\n    def websocket_client(self) -&gt; WebSocketClient:\n        \"\"\"Get the WebSocket client.\n\n        Raises:\n            RuntimeError: If the application is not initialized.\n\n        Returns:\n            The WebSocketClient instance.\n\n        \"\"\"\n        if self.app.websocket_client is None:\n            message = \"Runtime not initialized. Call await app.initialize() first.\"\n            raise RuntimeError(message)\n        return self.app.websocket_client\n\n    @property\n    def message_service(self) -&gt; MessageService:\n        \"\"\"Get the message service.\n\n        Raises:\n            RuntimeError: If the application is not initialized.\n\n        Returns:\n            The MessageService instance.\n\n        \"\"\"\n        if self.app.message_service is None:\n            message = \"Runtime not initialized. Call await app.initialize() first.\"\n            raise RuntimeError(message)\n        return self.app.message_service\n\n    async def set_websocket_client(self, websocket_client: WebSocketClient) -&gt; None:\n        \"\"\"Override the websocket client (primarily for testing purposes).\n\n        Args:\n            websocket_client: The new WebSocketClient instance to use.\n\n        \"\"\"\n        await self.app.initialize()\n        self.app.websocket_client = websocket_client\n        if self.app.message_service is not None:\n            self.app.message_service.set_websocket_client(websocket_client)\n</code></pre> <p>Explicit wiring of Signal client runtime components.</p> <p>This class is responsible for initializing and managing the lifecycle of all components within the Signal client, including API clients, storage, message queues, and worker pools.</p> Source code in <code>signal_client/app/application.py</code> <pre><code>class Application:\n    \"\"\"Explicit wiring of Signal client runtime components.\n\n    This class is responsible for initializing and managing the lifecycle\n    of all components within the Signal client, including API clients,\n    storage, message queues, and worker pools.\n    \"\"\"\n\n    def __init__(\n        self, settings: Settings, *, header_provider: HeaderProvider | None = None\n    ) -&gt; None:\n        \"\"\"Initialize the Application instance.\n\n        Args:\n            settings: The application settings.\n            header_provider: An optional callable or object that provides\n                             additional HTTP headers for API requests.\n\n        \"\"\"\n        ensure_structlog_configured(redaction_enabled=settings.log_redaction_enabled)\n        self._log = structlog.get_logger()\n        self.settings = settings\n        self._header_provider = header_provider\n        self.session: aiohttp.ClientSession | None = None\n        self.rate_limiter = RateLimiter(\n            rate_limit=settings.rate_limit, period=settings.rate_limit_period\n        )\n        self.circuit_breaker = CircuitBreaker(\n            failure_threshold=settings.circuit_breaker_failure_threshold,\n            reset_timeout=settings.circuit_breaker_reset_timeout,\n            failure_rate_threshold=settings.circuit_breaker_failure_rate_threshold,\n            min_requests_for_rate_calc=(\n                settings.circuit_breaker_min_requests_for_rate_calc\n            ),\n        )\n\n        self.storage = self._create_storage()\n        if isinstance(self.storage, MemoryStorage):\n            self._log_warning(\n                \"Using transient in-memory storage. No data will be persisted.\",\n                event_slug=\"storage.in_memory.active\",\n            )\n\n        self.api_clients: APIClients | None = None\n\n        self.queue: asyncio.Queue[QueuedMessage] | None = None\n        self.websocket_client: WebSocketClient | None = None\n        self.dead_letter_queue: DeadLetterQueue | None = None\n        self.persistent_queue: PersistentQueue | None = None\n        self.ingest_checkpoint_store: IngestCheckpointStore | None = None\n        self.intake_controller: IntakeController | None = None\n        self.message_parser = MessageParser()\n        self.lock_manager: LockManager | None = None\n        self.context_dependencies: ContextDependencies | None = None\n        self.context_factory: Callable[[Message], Context] | None = None\n        self.message_service: MessageService | None = None\n        self.worker_pool: WorkerPool | None = None\n        self._circuit_state_lock: asyncio.Lock | None = None\n        self._open_circuit_endpoints: set[str] = set()\n\n    def _log_warning(self, message: str, **kwargs: object) -&gt; None:\n        \"\"\"Emit a warning, tolerating minimal structlog configurations.\n\n        Falls back to stdlib logging if the current structlog logger does not\n        accept keyword arguments (e.g., when using PrintLogger).\n        \"\"\"\n        safe_log(self._log, \"warning\", message, **kwargs)\n\n    async def initialize(self) -&gt; None:\n        \"\"\"Initialize all components of the application.\n\n        This method sets up the AIOHTTP client session, API clients,\n        message queues, storage, and worker pools. It must be called\n        before the application can start processing messages.\n        \"\"\"\n        if self.queue is not None:\n            return\n\n        self.session = aiohttp.ClientSession()\n        self.api_clients = self._create_api_clients(self.session)\n\n        self.queue = asyncio.Queue(maxsize=self.settings.queue_size)\n        if self.settings.durable_queue_enabled:\n            self.persistent_queue = PersistentQueue(\n                storage=self.storage,\n                key=self.settings.ingest_queue_name,\n                max_length=self.settings.durable_queue_max_length,\n            )\n        self.ingest_checkpoint_store = IngestCheckpointStore(\n            storage=self.storage,\n            key=self.settings.ingest_checkpoint_key,\n            window_size=self.settings.ingest_checkpoint_window,\n        )\n        self.intake_controller = IntakeController(\n            default_pause_seconds=self.settings.ingest_pause_seconds\n        )\n        self.rate_limiter.set_wait_listener(self._handle_rate_limit_wait)\n        self._circuit_state_lock = asyncio.Lock()\n        self.websocket_client = WebSocketClient(\n            signal_service_url=self.settings.signal_service,\n            phone_number=self.settings.phone_number,\n            websocket_path=self.settings.websocket_path,\n        )\n        redis_client = (\n            self.storage.client\n            if self.settings.distributed_locks_enabled\n            and isinstance(self.storage, RedisStorage)\n            else None\n        )\n        self.lock_manager = LockManager(\n            redis_client=redis_client,\n            lock_timeout_seconds=self.settings.distributed_lock_timeout,\n        )\n        self.dead_letter_queue = DeadLetterQueue(\n            storage=self.storage,\n            queue_name=self.settings.dlq_name,\n            max_retries=self.settings.dlq_max_retries,\n        )\n        self.context_dependencies = ContextDependencies(\n            accounts_client=self.api_clients.accounts,\n            attachments_client=self.api_clients.attachments,\n            contacts_client=self.api_clients.contacts,\n            devices_client=self.api_clients.devices,\n            general_client=self.api_clients.general,\n            groups_client=self.api_clients.groups,\n            identities_client=self.api_clients.identities,\n            messages_client=self.api_clients.messages,\n            profiles_client=self.api_clients.profiles,\n            reactions_client=self.api_clients.reactions,\n            receipts_client=self.api_clients.receipts,\n            search_client=self.api_clients.search,\n            sticker_packs_client=self.api_clients.sticker_packs,\n            lock_manager=self.lock_manager,\n            phone_number=self.settings.phone_number,\n            settings=self.settings,\n        )\n        self.context_factory = partial(Context, dependencies=self.context_dependencies)\n        self.message_service = MessageService(\n            websocket_client=self.websocket_client,\n            queue=self.queue,\n            dead_letter_queue=self.dead_letter_queue,\n            persistent_queue=self.persistent_queue,\n            intake_controller=self.intake_controller,\n            enqueue_timeout=self.settings.queue_put_timeout,\n            backpressure_policy=(\n                BackpressurePolicy.DROP_OLDEST\n                if self.settings.queue_drop_oldest_on_timeout\n                else BackpressurePolicy.FAIL_FAST\n            ),\n        )\n        self.circuit_breaker.register_state_listener(self._handle_circuit_state_change)\n        self.worker_pool = WorkerPool(\n            context_factory=self.context_factory,\n            queue=self.queue,\n            message_parser=self.message_parser,\n            dead_letter_queue=self.dead_letter_queue,\n            checkpoint_store=self.ingest_checkpoint_store,\n            pool_size=self.settings.worker_pool_size,\n            shard_count=self.settings.worker_shard_count,\n            lock_manager=self.lock_manager,\n        )\n        if self.persistent_queue:\n            replay = await self.persistent_queue.replay()\n            for item in replay:\n                queued = QueuedMessage(raw=item.raw, enqueued_at=item.enqueued_at)\n                try:\n                    self.queue.put_nowait(queued)\n                except asyncio.QueueFull:\n                    self._log_warning(\n                        \"persistent_queue.replay_dropped\",\n                        reason=\"queue_full\",\n                        queue_depth=self.queue.qsize(),\n                        queue_maxsize=self.queue.maxsize,\n                    )\n                    break\n\n    def _create_storage(self) -&gt; Storage:\n        \"\"\"Create and return the appropriate storage backend based on settings.\n\n        Returns:\n            An instance of a concrete Storage implementation (RedisStorage,\n            SQLiteStorage, or MemoryStorage).\n\n        \"\"\"\n        storage_type = self.settings.storage_type.lower()\n        if storage_type == \"redis\":\n            return RedisStorage(\n                host=self.settings.redis_host,\n                port=self.settings.redis_port,\n            )\n        if storage_type == \"sqlite\":\n            return SQLiteStorage(database=self.settings.sqlite_database)\n        return MemoryStorage()\n\n    def _create_api_clients(self, session: aiohttp.ClientSession) -&gt; APIClients:\n        \"\"\"Create and return a collection of API clients.\n\n        Args:\n            session: The aiohttp client session to use for requests.\n\n        Returns:\n            An APIClients instance containing all initialized API clients.\n\n        \"\"\"\n        client_config = ClientConfig(\n            session=session,\n            base_url=self.settings.base_url,\n            retries=self.settings.api_retries,\n            backoff_factor=self.settings.api_backoff_factor,\n            timeout=self.settings.api_timeout,\n            rate_limiter=self.rate_limiter,\n            circuit_breaker=self.circuit_breaker,\n            default_headers=self._default_api_headers(),\n            header_provider=self._header_provider,\n            endpoint_timeouts=self.settings.api_endpoint_timeouts,\n            idempotency_header_name=self.settings.api_idempotency_header,\n        )\n        return APIClients(\n            accounts=AccountsClient(client_config=client_config),\n            attachments=AttachmentsClient(client_config=client_config),\n            contacts=ContactsClient(client_config=client_config),\n            devices=DevicesClient(client_config=client_config),\n            general=GeneralClient(client_config=client_config),\n            groups=GroupsClient(client_config=client_config),\n            identities=IdentitiesClient(client_config=client_config),\n            messages=MessagesClient(client_config=client_config),\n            profiles=ProfilesClient(client_config=client_config),\n            reactions=ReactionsClient(client_config=client_config),\n            receipts=ReceiptsClient(client_config=client_config),\n            search=SearchClient(client_config=client_config),\n            sticker_packs=StickerPacksClient(client_config=client_config),\n        )\n\n    def _default_api_headers(self) -&gt; dict[str, str]:\n        \"\"\"Construct a dictionary of default headers for API requests.\n\n        Includes authorization header if an API token is configured.\n\n        Returns:\n            A dictionary of HTTP headers.\n\n        \"\"\"\n        headers = dict(self.settings.api_default_headers)\n        token = (self.settings.api_auth_token or \"\").strip()\n        if token:\n            scheme = (self.settings.api_auth_scheme or \"\").strip()\n            auth_value = f\"{scheme} {token}\".strip() if scheme else token\n            headers.setdefault(\"Authorization\", auth_value)\n        return headers\n\n    async def shutdown(self) -&gt; None:\n        \"\"\"Shut down the application gracefully.\"\"\"\n        if self.websocket_client is not None:\n            await self.websocket_client.close()\n        if self.session is not None:\n            await self.session.close()\n        close_storage = getattr(self.storage, \"close\", None)\n        if close_storage is not None:\n            await close_storage()\n\n    async def _handle_circuit_state_change(\n        self, endpoint: str, state: CircuitBreakerState\n    ) -&gt; None:\n        \"\"\"Handle changes in the circuit breaker state for a given endpoint.\n\n        If a circuit opens, the intake controller may be paused. If all\n        circuits close, the intake controller may be resumed.\n\n        Args:\n            endpoint: The API endpoint whose circuit breaker state changed.\n            state: The new state of the circuit breaker.\n\n        \"\"\"\n        if self.intake_controller is None or self._circuit_state_lock is None:\n            return\n\n        pause = False\n        resume = False\n        pause_duration = float(\n            max(\n                self.settings.ingest_pause_seconds,\n                self.settings.circuit_breaker_reset_timeout,\n            )\n        )\n        async with self._circuit_state_lock:\n            if state is CircuitBreakerState.OPEN:\n                self._open_circuit_endpoints.add(endpoint)\n                pause = True\n            elif state is CircuitBreakerState.HALF_OPEN:\n                self._open_circuit_endpoints.add(endpoint)\n            elif state is CircuitBreakerState.CLOSED:\n                self._open_circuit_endpoints.discard(endpoint)\n                if not self._open_circuit_endpoints:\n                    resume = True\n\n        if pause:\n            await self.intake_controller.pause(\n                reason=\"circuit_open\", duration=pause_duration\n            )\n        elif resume:\n            await self.intake_controller.resume_now()\n\n    async def _handle_rate_limit_wait(self, wait_time: float) -&gt; None:\n        \"\"\"Handle a rate limit wait by pausing the intake controller.\n\n        Args:\n            wait_time: The duration (in seconds) to wait due to rate limiting.\n\n        \"\"\"\n        if self.intake_controller is None:\n            return\n\n        pause_for = max(wait_time, self.settings.ingest_pause_seconds)\n        await self.intake_controller.pause(reason=\"rate_limited\", duration=pause_for)\n</code></pre>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.queue","title":"queue  <code>property</code>","text":"<pre><code>queue: Queue[QueuedMessage]\n</code></pre> <p>Get the message queue.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the application is not initialized.</p> <p>Returns:</p> Type Description <code>Queue[QueuedMessage]</code> <p>The asyncio.Queue for messages.</p>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.worker_pool","title":"worker_pool  <code>property</code>","text":"<pre><code>worker_pool: WorkerPool\n</code></pre> <p>Get the worker pool.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the application is not initialized.</p> <p>Returns:</p> Type Description <code>WorkerPool</code> <p>The WorkerPool instance.</p>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.api_clients","title":"api_clients  <code>property</code>","text":"<pre><code>api_clients: APIClients\n</code></pre> <p>Get the API clients.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the application is not initialized.</p> <p>Returns:</p> Type Description <code>APIClients</code> <p>The APIClients instance.</p>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.websocket_client","title":"websocket_client  <code>property</code>","text":"<pre><code>websocket_client: WebSocketClient\n</code></pre> <p>Get the WebSocket client.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the application is not initialized.</p> <p>Returns:</p> Type Description <code>WebSocketClient</code> <p>The WebSocketClient instance.</p>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.message_service","title":"message_service  <code>property</code>","text":"<pre><code>message_service: MessageService\n</code></pre> <p>Get the message service.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the application is not initialized.</p> <p>Returns:</p> Type Description <code>MessageService</code> <p>The MessageService instance.</p>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.__init__","title":"__init__","text":"<pre><code>__init__(\n    config: dict | None = None,\n    app: Application | None = None,\n    header_provider: HeaderProvider | None = None,\n) -&gt; None\n</code></pre> <p>Initialize the SignalClient.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict | None</code> <p>A dictionary of configuration overrides.</p> <code>None</code> <code>app</code> <code>Application | None</code> <p>An optional pre-initialized Application instance.</p> <code>None</code> <code>header_provider</code> <code>HeaderProvider | None</code> <p>An optional callable or object that provides              additional HTTP headers for API requests.</p> <code>None</code> Source code in <code>signal_client/app/bot.py</code> <pre><code>def __init__(\n    self,\n    config: dict | None = None,\n    app: Application | None = None,\n    header_provider: HeaderProvider | None = None,\n) -&gt; None:\n    \"\"\"Initialize the SignalClient.\n\n    Args:\n        config: A dictionary of configuration overrides.\n        app: An optional pre-initialized Application instance.\n        header_provider: An optional callable or object that provides\n                         additional HTTP headers for API requests.\n\n    \"\"\"\n    check_supported_versions()\n    settings = Settings.from_sources(config=config)\n\n    ensure_structlog_configured(redaction_enabled=settings.log_redaction_enabled)\n    self.app = app or Application(settings, header_provider=header_provider)\n    self.settings = settings\n    self._commands: list[Command] = []\n    self._registered_command_ids: set[int] = set()\n    self._middleware: list[\n        Callable[[Context, Callable[[Context], Awaitable[None]]], Awaitable[None]]\n    ] = []\n</code></pre>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.register","title":"register","text":"<pre><code>register(command: Command) -&gt; None\n</code></pre> <p>Register a new command with the client.</p> <p>Registered commands will be executed when matching incoming messages.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>Command</code> <p>The Command instance to register.</p> required Source code in <code>signal_client/app/bot.py</code> <pre><code>def register(self, command: Command) -&gt; None:\n    \"\"\"Register a new command with the client.\n\n    Registered commands will be executed when matching incoming messages.\n\n    Args:\n        command: The Command instance to register.\n\n    \"\"\"\n    self._commands.append(command)\n    self._register_with_worker_pool(command)\n</code></pre>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.use","title":"use","text":"<pre><code>use(\n    middleware: Callable[\n        [Context, Callable[[Context], Awaitable[None]]],\n        Awaitable[None],\n    ],\n) -&gt; None\n</code></pre> <p>Register middleware to wrap command execution.</p> <p>Middleware functions are called before command execution and can modify the context or prevent command execution.</p> <p>Parameters:</p> Name Type Description Default <code>middleware</code> <code>Callable[[Context, Callable[[Context], Awaitable[None]]], Awaitable[None]]</code> <p>The middleware callable to register.</p> required Source code in <code>signal_client/app/bot.py</code> <pre><code>def use(\n    self,\n    middleware: Callable[\n        [Context, Callable[[Context], Awaitable[None]]], Awaitable[None]\n    ],\n) -&gt; None:\n    \"\"\"Register middleware to wrap command execution.\n\n    Middleware functions are called before command execution and can\n    modify the context or prevent command execution.\n\n    Args:\n        middleware: The middleware callable to register.\n\n    \"\"\"\n    if middleware in self._middleware:\n        return\n    self._middleware.append(middleware)\n    if self.app.worker_pool is not None:\n        self.app.worker_pool.register_middleware(middleware)\n</code></pre>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Asynchronous context manager entry.</p> Source code in <code>signal_client/app/bot.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Asynchronous context manager entry.\"\"\"\n    await self.app.initialize()\n    return self\n</code></pre>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc: BaseException | None,\n    tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Asynchronous context manager exit.</p> <p>Ensures proper shutdown of the client.</p> Source code in <code>signal_client/app/bot.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc: BaseException | None,\n    tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Asynchronous context manager exit.\n\n    Ensures proper shutdown of the client.\n    \"\"\"\n    await self.shutdown()\n</code></pre>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the SignalClient, including message listening and worker processing.</p> <p>This method will block indefinitely until the client is shut down.</p> Source code in <code>signal_client/app/bot.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the SignalClient, including message listening and worker processing.\n\n    This method will block indefinitely until the client is shut down.\n    \"\"\"\n    await self.app.initialize()\n    if self.app.worker_pool is None or self.app.message_service is None:\n        message = \"Runtime not initialized. Call await app.initialize() first.\"\n        raise RuntimeError(message)\n    worker_pool = self.app.worker_pool\n    message_service = self.app.message_service\n\n    for command in self._commands:\n        self._register_with_worker_pool(command)\n\n    for middleware in self._middleware:\n        worker_pool.register_middleware(middleware)\n\n    worker_pool.start()\n\n    try:\n        await asyncio.gather(\n            message_service.listen(),\n            worker_pool.join(),\n        )\n    finally:\n        await self.shutdown()\n</code></pre>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Shut down the SignalClient gracefully.</p> <p>This involves closing the websocket, waiting for queues to empty, stopping workers, and closing the aiohttp session.</p> Source code in <code>signal_client/app/bot.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shut down the SignalClient gracefully.\n\n    This involves closing the websocket, waiting for queues to empty,\n    stopping workers, and closing the aiohttp session.\n    \"\"\"\n    # 1. Stop accepting new messages\n    if self.app.websocket_client is not None:\n        await self.app.websocket_client.close()\n\n    # 2. Wait for the queue to be empty\n    if self.app.queue is not None:\n        await self.app.queue.join()\n\n    # 3. Stop the workers\n    if self.app.worker_pool is not None:\n        self.app.worker_pool.stop()\n        await self.app.worker_pool.join()\n\n    # 4. Close the session and shutdown resources\n    if self.app.session is not None:\n        await self.app.session.close()\n    close_storage = getattr(self.app.storage, \"close\", None)\n    if close_storage is not None:\n        await close_storage()\n</code></pre>"},{"location":"reference/api/#signal_client.app.bot.SignalClient.set_websocket_client","title":"set_websocket_client  <code>async</code>","text":"<pre><code>set_websocket_client(\n    websocket_client: WebSocketClient,\n) -&gt; None\n</code></pre> <p>Override the websocket client (primarily for testing purposes).</p> <p>Parameters:</p> Name Type Description Default <code>websocket_client</code> <code>WebSocketClient</code> <p>The new WebSocketClient instance to use.</p> required Source code in <code>signal_client/app/bot.py</code> <pre><code>async def set_websocket_client(self, websocket_client: WebSocketClient) -&gt; None:\n    \"\"\"Override the websocket client (primarily for testing purposes).\n\n    Args:\n        websocket_client: The new WebSocketClient instance to use.\n\n    \"\"\"\n    await self.app.initialize()\n    self.app.websocket_client = websocket_client\n    if self.app.message_service is not None:\n        self.app.message_service.set_websocket_client(websocket_client)\n</code></pre>"},{"location":"reference/api/#signal_client.app.application.Application.__init__","title":"__init__","text":"<pre><code>__init__(\n    settings: Settings,\n    *,\n    header_provider: HeaderProvider | None = None\n) -&gt; None\n</code></pre> <p>Initialize the Application instance.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>Settings</code> <p>The application settings.</p> required <code>header_provider</code> <code>HeaderProvider | None</code> <p>An optional callable or object that provides              additional HTTP headers for API requests.</p> <code>None</code> Source code in <code>signal_client/app/application.py</code> <pre><code>def __init__(\n    self, settings: Settings, *, header_provider: HeaderProvider | None = None\n) -&gt; None:\n    \"\"\"Initialize the Application instance.\n\n    Args:\n        settings: The application settings.\n        header_provider: An optional callable or object that provides\n                         additional HTTP headers for API requests.\n\n    \"\"\"\n    ensure_structlog_configured(redaction_enabled=settings.log_redaction_enabled)\n    self._log = structlog.get_logger()\n    self.settings = settings\n    self._header_provider = header_provider\n    self.session: aiohttp.ClientSession | None = None\n    self.rate_limiter = RateLimiter(\n        rate_limit=settings.rate_limit, period=settings.rate_limit_period\n    )\n    self.circuit_breaker = CircuitBreaker(\n        failure_threshold=settings.circuit_breaker_failure_threshold,\n        reset_timeout=settings.circuit_breaker_reset_timeout,\n        failure_rate_threshold=settings.circuit_breaker_failure_rate_threshold,\n        min_requests_for_rate_calc=(\n            settings.circuit_breaker_min_requests_for_rate_calc\n        ),\n    )\n\n    self.storage = self._create_storage()\n    if isinstance(self.storage, MemoryStorage):\n        self._log_warning(\n            \"Using transient in-memory storage. No data will be persisted.\",\n            event_slug=\"storage.in_memory.active\",\n        )\n\n    self.api_clients: APIClients | None = None\n\n    self.queue: asyncio.Queue[QueuedMessage] | None = None\n    self.websocket_client: WebSocketClient | None = None\n    self.dead_letter_queue: DeadLetterQueue | None = None\n    self.persistent_queue: PersistentQueue | None = None\n    self.ingest_checkpoint_store: IngestCheckpointStore | None = None\n    self.intake_controller: IntakeController | None = None\n    self.message_parser = MessageParser()\n    self.lock_manager: LockManager | None = None\n    self.context_dependencies: ContextDependencies | None = None\n    self.context_factory: Callable[[Message], Context] | None = None\n    self.message_service: MessageService | None = None\n    self.worker_pool: WorkerPool | None = None\n    self._circuit_state_lock: asyncio.Lock | None = None\n    self._open_circuit_endpoints: set[str] = set()\n</code></pre>"},{"location":"reference/api/#signal_client.app.application.Application.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize() -&gt; None\n</code></pre> <p>Initialize all components of the application.</p> <p>This method sets up the AIOHTTP client session, API clients, message queues, storage, and worker pools. It must be called before the application can start processing messages.</p> Source code in <code>signal_client/app/application.py</code> <pre><code>async def initialize(self) -&gt; None:\n    \"\"\"Initialize all components of the application.\n\n    This method sets up the AIOHTTP client session, API clients,\n    message queues, storage, and worker pools. It must be called\n    before the application can start processing messages.\n    \"\"\"\n    if self.queue is not None:\n        return\n\n    self.session = aiohttp.ClientSession()\n    self.api_clients = self._create_api_clients(self.session)\n\n    self.queue = asyncio.Queue(maxsize=self.settings.queue_size)\n    if self.settings.durable_queue_enabled:\n        self.persistent_queue = PersistentQueue(\n            storage=self.storage,\n            key=self.settings.ingest_queue_name,\n            max_length=self.settings.durable_queue_max_length,\n        )\n    self.ingest_checkpoint_store = IngestCheckpointStore(\n        storage=self.storage,\n        key=self.settings.ingest_checkpoint_key,\n        window_size=self.settings.ingest_checkpoint_window,\n    )\n    self.intake_controller = IntakeController(\n        default_pause_seconds=self.settings.ingest_pause_seconds\n    )\n    self.rate_limiter.set_wait_listener(self._handle_rate_limit_wait)\n    self._circuit_state_lock = asyncio.Lock()\n    self.websocket_client = WebSocketClient(\n        signal_service_url=self.settings.signal_service,\n        phone_number=self.settings.phone_number,\n        websocket_path=self.settings.websocket_path,\n    )\n    redis_client = (\n        self.storage.client\n        if self.settings.distributed_locks_enabled\n        and isinstance(self.storage, RedisStorage)\n        else None\n    )\n    self.lock_manager = LockManager(\n        redis_client=redis_client,\n        lock_timeout_seconds=self.settings.distributed_lock_timeout,\n    )\n    self.dead_letter_queue = DeadLetterQueue(\n        storage=self.storage,\n        queue_name=self.settings.dlq_name,\n        max_retries=self.settings.dlq_max_retries,\n    )\n    self.context_dependencies = ContextDependencies(\n        accounts_client=self.api_clients.accounts,\n        attachments_client=self.api_clients.attachments,\n        contacts_client=self.api_clients.contacts,\n        devices_client=self.api_clients.devices,\n        general_client=self.api_clients.general,\n        groups_client=self.api_clients.groups,\n        identities_client=self.api_clients.identities,\n        messages_client=self.api_clients.messages,\n        profiles_client=self.api_clients.profiles,\n        reactions_client=self.api_clients.reactions,\n        receipts_client=self.api_clients.receipts,\n        search_client=self.api_clients.search,\n        sticker_packs_client=self.api_clients.sticker_packs,\n        lock_manager=self.lock_manager,\n        phone_number=self.settings.phone_number,\n        settings=self.settings,\n    )\n    self.context_factory = partial(Context, dependencies=self.context_dependencies)\n    self.message_service = MessageService(\n        websocket_client=self.websocket_client,\n        queue=self.queue,\n        dead_letter_queue=self.dead_letter_queue,\n        persistent_queue=self.persistent_queue,\n        intake_controller=self.intake_controller,\n        enqueue_timeout=self.settings.queue_put_timeout,\n        backpressure_policy=(\n            BackpressurePolicy.DROP_OLDEST\n            if self.settings.queue_drop_oldest_on_timeout\n            else BackpressurePolicy.FAIL_FAST\n        ),\n    )\n    self.circuit_breaker.register_state_listener(self._handle_circuit_state_change)\n    self.worker_pool = WorkerPool(\n        context_factory=self.context_factory,\n        queue=self.queue,\n        message_parser=self.message_parser,\n        dead_letter_queue=self.dead_letter_queue,\n        checkpoint_store=self.ingest_checkpoint_store,\n        pool_size=self.settings.worker_pool_size,\n        shard_count=self.settings.worker_shard_count,\n        lock_manager=self.lock_manager,\n    )\n    if self.persistent_queue:\n        replay = await self.persistent_queue.replay()\n        for item in replay:\n            queued = QueuedMessage(raw=item.raw, enqueued_at=item.enqueued_at)\n            try:\n                self.queue.put_nowait(queued)\n            except asyncio.QueueFull:\n                self._log_warning(\n                    \"persistent_queue.replay_dropped\",\n                    reason=\"queue_full\",\n                    queue_depth=self.queue.qsize(),\n                    queue_maxsize=self.queue.maxsize,\n                )\n                break\n</code></pre>"},{"location":"reference/api/#signal_client.app.application.Application.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Shut down the application gracefully.</p> Source code in <code>signal_client/app/application.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shut down the application gracefully.\"\"\"\n    if self.websocket_client is not None:\n        await self.websocket_client.close()\n    if self.session is not None:\n        await self.session.close()\n    close_storage = getattr(self.storage, \"close\", None)\n    if close_storage is not None:\n        await close_storage()\n</code></pre>"},{"location":"reference/api/#commands-and-context","title":"Commands and context","text":"<p>Provide helpers for command handlers interacting with the Signal API.</p> <p>Instances of this class are passed to command handler functions, encapsulating the incoming message and all necessary API clients and utilities.</p> Source code in <code>signal_client/core/context.py</code> <pre><code>class Context:\n    \"\"\"Provide helpers for command handlers interacting with the Signal API.\n\n    Instances of this class are passed to command handler functions,\n    encapsulating the incoming message and all necessary API clients\n    and utilities.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: Message,\n        dependencies: ContextDependencies,\n    ) -&gt; None:\n        \"\"\"Initialize a Context instance.\n\n        Args:\n            message: The incoming message that triggered the command.\n            dependencies: An instance of ContextDependencies providing\n                          access to various clients and managers.\n\n        \"\"\"\n        self.message = message\n        self.accounts = dependencies.accounts_client\n        self.attachments = dependencies.attachments_client\n        self.contacts = dependencies.contacts_client\n        self.devices = dependencies.devices_client\n        self.general = dependencies.general_client\n        self.groups = dependencies.groups_client\n        self.identities = dependencies.identities_client\n        self.messages = dependencies.messages_client\n        self.profiles = dependencies.profiles_client\n        self.reactions = dependencies.reactions_client\n        self.receipts = dependencies.receipts_client\n        self.search = dependencies.search_client\n        self.sticker_packs = dependencies.sticker_packs_client\n        self.settings = dependencies.settings\n        self._phone_number = dependencies.phone_number\n        self._lock_manager = dependencies.lock_manager\n\n        self._attachment_downloader = AttachmentDownloader(self.attachments)\n\n    async def send(self, request: SendMessageRequest) -&gt; SendMessageResponse | None:\n        \"\"\"Send a message to a recipient.\n\n        Args:\n            request: The SendMessageRequest object containing message details.\n\n        Returns:\n            A SendMessageResponse object if successful, otherwise None.\n\n        \"\"\"\n        normalized = self._prepare_send_request(request)\n        request_options = (\n            RequestOptions(idempotency_key=normalized.idempotency_key)\n            if normalized.idempotency_key\n            else None\n        )\n        response = await self.messages.send(\n            normalized.model_dump(exclude_none=True, by_alias=True),\n            request_options=request_options,\n        )\n        return SendMessageResponse.from_raw(response)\n\n    async def reply(self, request: SendMessageRequest) -&gt; SendMessageResponse | None:\n        \"\"\"Reply to the incoming message, quoting it.\n\n        The original message's author, content, and timestamp are\n        automatically included in the quote.\n\n        Args:\n            request: The SendMessageRequest object containing message details.\n\n        Returns:\n            A SendMessageResponse object if successful, otherwise None.\n\n        \"\"\"\n        request.quote_author = self.message.source\n        request.quote_message = self.message.message\n        request.quote_timestamp = self.message.timestamp\n        return await self.send(request)\n\n    async def send_text(  # noqa: PLR0913\n        self,\n        text: str,\n        *,\n        recipients: Sequence[str] | None = None,\n        mentions: list[MessageMention] | None = None,\n        quote_mentions: list[MessageMention] | None = None,\n        base64_attachments: list[str] | None = None,\n        link_preview: LinkPreview | None = None,\n        text_mode: Literal[\"normal\", \"styled\"] | None = None,\n        notify_self: bool | None = None,\n        edit_timestamp: int | None = None,\n        sticker: str | None = None,\n        view_once: bool = False,\n    ) -&gt; SendMessageResponse | None:\n        \"\"\"Send a plain text message.\n\n        Args:\n            text: The text content of the message.\n            recipients: Optional list of recipient IDs (phone numbers or group\n                IDs). Defaults to the sender of the incoming message.\n            mentions: Optional list of MessageMention objects for @mentions.\n            quote_mentions: Optional list of MessageMention objects for mentions\n                within a quote.\n            base64_attachments: Optional list of base64 encoded attachments.\n            link_preview: Optional LinkPreview object for a URL preview.\n            text_mode: 'normal' for plain text, 'styled' for markdown.\n            notify_self: Whether to send a notification to self.\n            edit_timestamp: Timestamp of the message to edit.\n            sticker: ID of a sticker to send.\n            view_once: If True, the message/attachments can only be viewed once.\n\n        Returns:\n            A SendMessageResponse object if successful, otherwise None.\n\n        \"\"\"\n        request = SendMessageRequest(\n            message=text,\n            recipients=list(recipients) if recipients else None,\n            base64_attachments=base64_attachments or [],\n            mentions=mentions,\n            quote_mentions=quote_mentions,\n            link_preview=link_preview,\n            text_mode=text_mode,\n            notify_self=notify_self,\n            edit_timestamp=edit_timestamp,\n            sticker=sticker,\n            view_once=view_once,\n        )\n        return await self.send(request)\n\n    async def reply_text(  # noqa: PLR0913\n        self,\n        text: str,\n        *,\n        recipients: Sequence[str] | None = None,\n        mentions: list[MessageMention] | None = None,\n        quote_mentions: list[MessageMention] | None = None,\n        base64_attachments: list[str] | None = None,\n        link_preview: LinkPreview | None = None,\n        text_mode: Literal[\"normal\", \"styled\"] | None = None,\n        notify_self: bool | None = None,\n        edit_timestamp: int | None = None,\n        sticker: str | None = None,\n        view_once: bool = False,\n    ) -&gt; SendMessageResponse | None:\n        \"\"\"Reply to the incoming message with plain text, quoting it.\n\n        Args:\n            text: The text content of the reply message.\n            recipients: Optional list of recipient IDs (phone numbers or group\n                IDs). Defaults to the sender of the incoming message.\n            mentions: Optional list of MessageMention objects for @mentions.\n            quote_mentions: Optional list of MessageMention objects for mentions\n                within a quote.\n            base64_attachments: Optional list of base64 encoded attachments.\n            link_preview: Optional LinkPreview object for a URL preview.\n            text_mode: 'normal' for plain text, 'styled' for markdown.\n            notify_self: Whether to send a notification to self.\n            edit_timestamp: Timestamp of the message to edit.\n            sticker: ID of a sticker to send.\n            view_once: If True, the message/attachments can only be viewed once.\n\n        Returns:\n            A SendMessageResponse object if successful, otherwise None.\n\n        \"\"\"\n        request = SendMessageRequest(\n            message=text,\n            recipients=list(recipients) if recipients else None,\n            base64_attachments=base64_attachments or [],\n            mentions=mentions,\n            quote_mentions=quote_mentions,\n            link_preview=link_preview,\n            text_mode=text_mode,\n            notify_self=notify_self,\n            edit_timestamp=edit_timestamp,\n            sticker=sticker,\n            view_once=view_once,\n        )\n        return await self.reply(request)\n\n    async def send_markdown(\n        self,\n        text: str,\n        *,\n        recipients: Sequence[str] | None = None,\n        mentions: list[MessageMention] | None = None,\n    ) -&gt; SendMessageResponse | None:\n        \"\"\"Send a message with markdown formatting.\n\n        Args:\n            text: The markdown formatted text content of the message.\n            recipients: Optional list of recipient IDs.\n            mentions: Optional list of MessageMention objects for @mentions.\n\n        Returns:\n            A SendMessageResponse object if successful, otherwise None.\n\n        \"\"\"\n        return await self.send_text(\n            text,\n            recipients=recipients,\n            mentions=mentions,\n            text_mode=\"styled\",\n        )\n\n    async def send_sticker(\n        self,\n        pack_id: str,\n        sticker_id: int | str,\n        *,\n        caption: str | None = None,\n        recipients: Sequence[str] | None = None,\n        notify_self: bool | None = None,\n    ) -&gt; SendMessageResponse | None:\n        \"\"\"Send a sticker message.\n\n        Args:\n            pack_id: The ID of the sticker pack.\n            sticker_id: The ID of the sticker within the pack.\n            caption: Optional caption for the sticker.\n            recipients: Optional list of recipient IDs.\n            notify_self: Whether to send a notification to self.\n\n        Returns:\n            A SendMessageResponse object if successful, otherwise None.\n\n        \"\"\"\n        sticker_ref = f\"{pack_id}:{sticker_id}\"\n        return await self.send_text(\n            caption or \"\",\n            recipients=recipients,\n            sticker=sticker_ref,\n            notify_self=notify_self,\n        )\n\n    async def send_view_once(\n        self,\n        attachments: list[str],\n        *,\n        message: str = \"\",\n        recipients: Sequence[str] | None = None,\n        notify_self: bool | None = None,\n    ) -&gt; SendMessageResponse | None:\n        \"\"\"Send a view-once message with attachments.\n\n        Args:\n            attachments: List of base64 encoded attachments.\n            message: Optional text message to accompany the view-once attachments.\n            recipients: Optional list of recipient IDs.\n            notify_self: Whether to send a notification to self.\n\n        Returns:\n            A SendMessageResponse object if successful, otherwise None.\n\n        \"\"\"\n        return await self.send_text(\n            message,\n            recipients=recipients,\n            base64_attachments=attachments,\n            view_once=True,\n            notify_self=notify_self,\n        )\n\n    async def send_with_preview(  # noqa: PLR0913\n        self,\n        url: str,\n        *,\n        message: str | None = None,\n        title: str | None = None,\n        description: str | None = None,\n        recipients: Sequence[str] | None = None,\n        text_mode: Literal[\"normal\", \"styled\"] | None = None,\n    ) -&gt; SendMessageResponse | None:\n        \"\"\"Send a message with a link preview.\n\n        Args:\n            url: The URL for which to generate a preview.\n            message: Optional text message to accompany the link preview.\n            title: Optional title for the link preview.\n            description: Optional description for the link preview.\n            recipients: Optional list of recipient IDs.\n            text_mode: 'normal' for plain text, 'styled' for markdown.\n\n        Returns:\n            A SendMessageResponse object if successful, otherwise None.\n\n        \"\"\"\n        preview = LinkPreview(\n            url=url,\n            title=title,\n            description=description,\n        )\n        return await self.send_text(\n            message or url,\n            recipients=recipients,\n            link_preview=preview,\n            text_mode=text_mode,\n        )\n\n    @asynccontextmanager\n    async def download_attachments(\n        self,\n        attachments: Sequence[AttachmentPointer] | None = None,\n        *,\n        max_total_bytes: int = DEFAULT_MAX_TOTAL_BYTES,\n        dest_dir: str | Path | None = None,\n    ) -&gt; AsyncGenerator[list[Path], None]:\n        \"\"\"Download attachments associated with the current message or a provided list.\n\n        This is an asynchronous context manager that yields a list of `Path`\n        objects pointing to the downloaded files. The files are cleaned up\n        automatically upon exiting the context.\n\n        Args:\n            attachments: An optional sequence of `AttachmentPointer` objects\n                to download.\n                If not provided, attachments from `self.message` are used.\n            max_total_bytes: The maximum total size (in bytes) of attachments\n                to download.\n                Defaults to `DEFAULT_MAX_TOTAL_BYTES`.\n            dest_dir: Optional directory to save the attachments. If not\n                provided, a temporary directory is used.\n\n        Yields:\n            A list of `pathlib.Path` objects to the downloaded attachment files.\n\n        \"\"\"\n        pointers: list[AttachmentPointer] = []\n        if attachments is not None:\n            pointers = list(attachments)\n        elif self.message.attachments:\n            pointers = list(self.message.attachments)\n\n        downloader = (\n            self._attachment_downloader\n            if max_total_bytes == self._attachment_downloader.max_total_bytes\n            else AttachmentDownloader(self.attachments, max_total_bytes=max_total_bytes)\n        )\n        async with downloader.download(pointers, dest_dir=dest_dir) as files:\n            yield files\n\n    def mention_author(\n        self, text: str, mention_text: str | None = None\n    ) -&gt; MessageMention:\n        \"\"\"Create a MessageMention object for the author of the current message.\n\n        Args:\n            text: The full text content where the mention is located.\n            mention_text: The specific text used for the mention (e.g., \"@Alice\").\n                          If None, defaults to `self.message.source`.\n\n        Returns:\n            A `MessageMention` object suitable for use in `SendMessageRequest`.\n\n        Raises:\n            ValueError: If the `mention_text` is not found within the provided `text`.\n\n        \"\"\"\n        mention_value = mention_text or self.message.source\n        start = text.find(mention_value)\n        if start &lt; 0:\n            message = \"mention text must exist within the provided text\"\n            raise ValueError(message)\n        return MessageMention(\n            author=self.message.source, start=start, length=len(mention_value)\n        )\n\n    async def reply_with_quote_mentions(\n        self,\n        text: str,\n        mentions: list[MessageMention] | None = None,\n    ) -&gt; SendMessageResponse | None:\n        \"\"\"Reply with text while quoting and mentioning the original author.\n\n        Attempts to mention the author of the original message when possible.\n\n        Args:\n            text: The text content of the reply message.\n            mentions: Optional list of additional MessageMention objects for @mentions.\n\n        Returns:\n            A SendMessageResponse object if successful, otherwise None.\n\n        \"\"\"\n        quote_mentions = mentions\n        if quote_mentions is None and self.message.message:\n            try:\n                quote_mentions = [self.mention_author(self.message.message)]\n            except ValueError:\n                quote_mentions = None\n\n        return await self.reply_text(\n            text,\n            quote_mentions=quote_mentions,\n        )\n\n    async def react(self, emoji: str) -&gt; None:\n        \"\"\"Add a reaction (emoji) to the incoming message.\n\n        Args:\n            emoji: The emoji string to react with (e.g., \"\ud83d\udc4d\").\n\n        \"\"\"\n        request = ReactionRequest(\n            reaction=emoji,\n            target_author=self.message.source,\n            timestamp=self.message.timestamp,\n            recipient=self._recipient(),\n        )\n        await self.reactions.send_reaction(\n            self._phone_number,\n            request.model_dump(by_alias=True, exclude_none=True),\n        )\n\n    async def remove_reaction(self) -&gt; None:\n        \"\"\"Remove a reaction from the incoming message.\n\n        This method will only attempt removal if `self.message.reaction_emoji` is\n        set, indicating a reaction was present on the original message.\n        \"\"\"\n        if not self.message.reaction_emoji:\n            return\n\n        request = ReactionRequest(\n            reaction=self.message.reaction_emoji,\n            target_author=self.message.source,\n            timestamp=self.message.timestamp,\n            recipient=self._recipient(),\n        )\n        await self.reactions.remove_reaction(\n            self._phone_number,\n            request.model_dump(by_alias=True, exclude_none=True),\n        )\n\n    async def show_typing(self) -&gt; None:\n        \"\"\"Send a typing indicator to the sender of the incoming message.\"\"\"\n        request = TypingIndicatorRequest(recipient=self._recipient())\n        await self.messages.set_typing_indicator(\n            self._phone_number, request.model_dump(exclude_none=True, by_alias=True)\n        )\n\n    async def hide_typing(self) -&gt; None:\n        \"\"\"Hide the typing indicator from the sender of the incoming message.\"\"\"\n        request = TypingIndicatorRequest(recipient=self._recipient())\n        await self.messages.unset_typing_indicator(\n            self._phone_number, request.model_dump(exclude_none=True, by_alias=True)\n        )\n\n    async def start_typing(self) -&gt; None:\n        \"\"\"Alias for show_typing for backward compatibility.\"\"\"\n        await self.show_typing()\n\n    async def stop_typing(self) -&gt; None:\n        \"\"\"Alias for hide_typing for backward compatibility.\"\"\"\n        await self.hide_typing()\n\n    async def send_receipt(\n        self,\n        target_timestamp: int,\n        *,\n        receipt_type: Literal[\"read\", \"viewed\"] = \"read\",\n        recipient: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a read or viewed receipt for a message.\n\n        Args:\n            target_timestamp: The timestamp of the message for which to send\n                the receipt.\n            receipt_type: The type of receipt to send ('read' or 'viewed').\n                Defaults to 'read'.\n            recipient: Optional recipient ID. Defaults to the sender of the\n                incoming message.\n\n        \"\"\"\n        payload = ReceiptRequest(\n            recipient=recipient or self._recipient(),\n            timestamp=target_timestamp,\n            receipt_type=receipt_type,\n        )\n        await self.receipts.send_receipt(\n            self._phone_number,\n            payload.model_dump(exclude_none=True, by_alias=True),\n        )\n\n    async def remote_delete(\n        self,\n        target_timestamp: int,\n        *,\n        recipient: str | None = None,\n        idempotency_key: str | None = None,\n    ) -&gt; RemoteDeleteResponse | None:\n        \"\"\"Remotely delete a message.\n\n        Args:\n            target_timestamp: The timestamp of the message to delete.\n            recipient: Optional recipient ID. Defaults to the sender of the\n                incoming message.\n            idempotency_key: An optional idempotency key for the request.\n\n        Returns:\n            A RemoteDeleteResponse object if successful, otherwise None.\n\n        \"\"\"\n        request = RemoteDeleteRequest(\n            recipient=recipient or self._recipient(),\n            timestamp=target_timestamp,\n            idempotency_key=idempotency_key,\n        )\n        request_options = (\n            RequestOptions(idempotency_key=request.idempotency_key)\n            if request.idempotency_key\n            else None\n        )\n        response = await self.messages.remote_delete(\n            self._phone_number,\n            request.model_dump(exclude_none=True, by_alias=True),\n            request_options=request_options,\n        )\n        return RemoteDeleteResponse.from_raw(response)\n\n    @asynccontextmanager\n    async def lock(self, resource_id: str) -&gt; AsyncGenerator[None, None]:\n        \"\"\"Acquire a distributed lock for a specific resource.\n\n        This is an asynchronous context manager that ensures exclusive access\n        to a resource across multiple instances of the application.\n\n        Args:\n            resource_id: A unique identifier for the resource to lock.\n\n        Yields:\n            None, while the lock is held.\n\n        \"\"\"\n        async with self._lock_manager.lock(resource_id):\n            yield\n\n    def _prepare_send_request(self, request: SendMessageRequest) -&gt; SendMessageRequest:\n        \"\"\"Prepare a SendMessageRequest by backfilling recipient and sender number.\n\n        Args:\n            request: The SendMessageRequest to prepare.\n\n        Returns:\n            The prepared SendMessageRequest.\n\n        \"\"\"\n        if not request.recipients:\n            request.recipients = [self._recipient()]\n        if request.number is None:\n            request.number = self._phone_number\n        return request\n\n    def _recipient(self) -&gt; str:\n        \"\"\"Determine the default recipient for a message based on the incoming message.\n\n        If the incoming message is from a group, the group ID is returned.\n        Otherwise, the sender's source ID is returned.\n\n        Returns:\n            The recipient ID (phone number or group ID).\n\n        \"\"\"\n        if self.message.is_group() and self.message.group:\n            return self.message.group[\"groupId\"]\n        return self.message.source\n</code></pre> <p>Represents a single command that the bot can respond to.</p> <p>A command is defined by its triggers (patterns that match incoming messages), an optional whitelist of allowed senders, and a handler function that executes the command's logic.</p> Source code in <code>signal_client/core/command.py</code> <pre><code>class Command:\n    \"\"\"Represents a single command that the bot can respond to.\n\n    A command is defined by its triggers (patterns that match incoming messages),\n    an optional whitelist of allowed senders, and a handler function that\n    executes the command's logic.\n    \"\"\"\n\n    def __init__(\n        self,\n        triggers: list[str | re.Pattern],\n        whitelisted: list[str] | None = None,\n        *,\n        case_sensitive: bool = False,\n        metadata: CommandMetadata | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize a Command instance.\n\n        Args:\n            triggers: A list of strings or regular expressions that will\n                      trigger this command.\n            whitelisted: An optional list of sender IDs (phone numbers or group IDs)\n                         that are allowed to execute this command. If empty or None,\n                         all senders are allowed.\n            case_sensitive: If True, string triggers will be matched case-sensitively.\n                            Defaults to False.\n            metadata: Optional CommandMetadata to provide name, description, and usage.\n\n        \"\"\"\n        self.triggers = triggers\n        self.whitelisted = whitelisted or []\n        self.case_sensitive = case_sensitive\n        meta = metadata or CommandMetadata()\n        self.name = meta.name\n        self.description = meta.description\n        self.usage = meta.usage\n        self.handle: Callable[[Context], Awaitable[None]] | None = None\n\n    def with_handler(self, handler: Callable[[Context], Awaitable[None]]) -&gt; Command:\n        \"\"\"Assign a handler function to this command.\n\n        If name or description are not already set, they will be inferred\n        from the handler function's name and docstring.\n\n        Args:\n            handler: The asynchronous function that will be executed when\n                     this command is triggered. It must accept a Context object.\n\n        Returns:\n            The Command instance with the handler assigned.\n\n        \"\"\"\n        self.handle = handler\n        if self.name is None:\n            self.name = handler.__name__\n        if self.description is None:\n            doc = inspect.getdoc(handler)\n            self.description = doc.strip() if doc else None\n        return self\n\n    async def __call__(self, context: Context) -&gt; None:\n        \"\"\"Execute the command's handler function.\n\n        Args:\n            context: The Context object containing message details and API clients.\n\n        Raises:\n            CommandError: If no handler has been assigned to the command.\n\n        \"\"\"\n        if self.handle is None:\n            message = _COMMAND_HANDLER_NOT_SET\n            raise CommandError(message)\n        await self.handle(context)\n</code></pre>"},{"location":"reference/api/#signal_client.core.command.command","title":"signal_client.core.command.command","text":"<pre><code>command(\n    *triggers: str | Pattern,\n    whitelisted: Sequence[str] | None = None,\n    case_sensitive: bool = False,\n    name: str | None = None,\n    description: str | None = None,\n    usage: str | None = None\n) -&gt; Callable[\n    [Callable[[Context], Awaitable[None]]], Command\n]\n</code></pre> <p>Define a new command via decorator.</p> <p>This decorator simplifies the creation of Command instances by allowing you to define triggers, whitelisted senders, and other metadata directly on the handler function.</p> <p>Parameters:</p> Name Type Description Default <code>*triggers</code> <code>str | Pattern</code> <p>One or more strings or regular expressions that will        trigger this command.</p> <code>()</code> <code>whitelisted</code> <code>Sequence[str] | None</code> <p>An optional list of sender IDs that are allowed to          execute this command.</p> <code>None</code> <code>case_sensitive</code> <code>bool</code> <p>If True, string triggers will be matched case-sensitively.</p> <code>False</code> <code>name</code> <code>str | None</code> <p>An optional name for the command.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>An optional description for the command.</p> <code>None</code> <code>usage</code> <code>str | None</code> <p>Optional usage instructions for the command.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[[Context], Awaitable[None]]], Command]</code> <p>A decorator that transforms an asynchronous function into a Command object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no triggers are provided.</p> Source code in <code>signal_client/core/command.py</code> <pre><code>def command(\n    *triggers: str | re.Pattern,\n    whitelisted: Sequence[str] | None = None,\n    case_sensitive: bool = False,\n    name: str | None = None,\n    description: str | None = None,\n    usage: str | None = None,\n) -&gt; Callable[[Callable[[Context], Awaitable[None]]], Command]:\n    \"\"\"Define a new command via decorator.\n\n    This decorator simplifies the creation of Command instances by allowing\n    you to define triggers, whitelisted senders, and other metadata directly\n    on the handler function.\n\n    Args:\n        *triggers: One or more strings or regular expressions that will\n                   trigger this command.\n        whitelisted: An optional list of sender IDs that are allowed to\n                     execute this command.\n        case_sensitive: If True, string triggers will be matched case-sensitively.\n        name: An optional name for the command.\n        description: An optional description for the command.\n        usage: Optional usage instructions for the command.\n\n    Returns:\n        A decorator that transforms an asynchronous function into a Command object.\n\n    Raises:\n        ValueError: If no triggers are provided.\n\n    \"\"\"\n    if not triggers:\n        message = \"At least one trigger must be provided.\"\n        raise ValueError(message)\n\n    metadata = CommandMetadata(name=name, description=description, usage=usage)\n\n    def decorator(handler: Callable[[Context], Awaitable[None]]) -&gt; Command:\n        cmd = Command(\n            triggers=list(triggers),\n            whitelisted=list(whitelisted) if whitelisted is not None else None,\n            case_sensitive=case_sensitive,\n            metadata=metadata,\n        )\n        return cmd.with_handler(handler)\n\n    return decorator\n</code></pre>"},{"location":"reference/api/#signal_client.core.context.Context.reply_text","title":"reply_text  <code>async</code>","text":"<pre><code>reply_text(\n    text: str,\n    *,\n    recipients: Sequence[str] | None = None,\n    mentions: list[MessageMention] | None = None,\n    quote_mentions: list[MessageMention] | None = None,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    text_mode: Literal[\"normal\", \"styled\"] | None = None,\n    notify_self: bool | None = None,\n    edit_timestamp: int | None = None,\n    sticker: str | None = None,\n    view_once: bool = False\n) -&gt; SendMessageResponse | None\n</code></pre> <p>Reply to the incoming message with plain text, quoting it.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text content of the reply message.</p> required <code>recipients</code> <code>Sequence[str] | None</code> <p>Optional list of recipient IDs (phone numbers or group IDs). Defaults to the sender of the incoming message.</p> <code>None</code> <code>mentions</code> <code>list[MessageMention] | None</code> <p>Optional list of MessageMention objects for @mentions.</p> <code>None</code> <code>quote_mentions</code> <code>list[MessageMention] | None</code> <p>Optional list of MessageMention objects for mentions within a quote.</p> <code>None</code> <code>base64_attachments</code> <code>list[str] | None</code> <p>Optional list of base64 encoded attachments.</p> <code>None</code> <code>link_preview</code> <code>LinkPreview | None</code> <p>Optional LinkPreview object for a URL preview.</p> <code>None</code> <code>text_mode</code> <code>Literal['normal', 'styled'] | None</code> <p>'normal' for plain text, 'styled' for markdown.</p> <code>None</code> <code>notify_self</code> <code>bool | None</code> <p>Whether to send a notification to self.</p> <code>None</code> <code>edit_timestamp</code> <code>int | None</code> <p>Timestamp of the message to edit.</p> <code>None</code> <code>sticker</code> <code>str | None</code> <p>ID of a sticker to send.</p> <code>None</code> <code>view_once</code> <code>bool</code> <p>If True, the message/attachments can only be viewed once.</p> <code>False</code> <p>Returns:</p> Type Description <code>SendMessageResponse | None</code> <p>A SendMessageResponse object if successful, otherwise None.</p> Source code in <code>signal_client/core/context.py</code> <pre><code>async def reply_text(  # noqa: PLR0913\n    self,\n    text: str,\n    *,\n    recipients: Sequence[str] | None = None,\n    mentions: list[MessageMention] | None = None,\n    quote_mentions: list[MessageMention] | None = None,\n    base64_attachments: list[str] | None = None,\n    link_preview: LinkPreview | None = None,\n    text_mode: Literal[\"normal\", \"styled\"] | None = None,\n    notify_self: bool | None = None,\n    edit_timestamp: int | None = None,\n    sticker: str | None = None,\n    view_once: bool = False,\n) -&gt; SendMessageResponse | None:\n    \"\"\"Reply to the incoming message with plain text, quoting it.\n\n    Args:\n        text: The text content of the reply message.\n        recipients: Optional list of recipient IDs (phone numbers or group\n            IDs). Defaults to the sender of the incoming message.\n        mentions: Optional list of MessageMention objects for @mentions.\n        quote_mentions: Optional list of MessageMention objects for mentions\n            within a quote.\n        base64_attachments: Optional list of base64 encoded attachments.\n        link_preview: Optional LinkPreview object for a URL preview.\n        text_mode: 'normal' for plain text, 'styled' for markdown.\n        notify_self: Whether to send a notification to self.\n        edit_timestamp: Timestamp of the message to edit.\n        sticker: ID of a sticker to send.\n        view_once: If True, the message/attachments can only be viewed once.\n\n    Returns:\n        A SendMessageResponse object if successful, otherwise None.\n\n    \"\"\"\n    request = SendMessageRequest(\n        message=text,\n        recipients=list(recipients) if recipients else None,\n        base64_attachments=base64_attachments or [],\n        mentions=mentions,\n        quote_mentions=quote_mentions,\n        link_preview=link_preview,\n        text_mode=text_mode,\n        notify_self=notify_self,\n        edit_timestamp=edit_timestamp,\n        sticker=sticker,\n        view_once=view_once,\n    )\n    return await self.reply(request)\n</code></pre>"},{"location":"reference/api/#signal_client.core.context.Context.send_markdown","title":"send_markdown  <code>async</code>","text":"<pre><code>send_markdown(\n    text: str,\n    *,\n    recipients: Sequence[str] | None = None,\n    mentions: list[MessageMention] | None = None\n) -&gt; SendMessageResponse | None\n</code></pre> <p>Send a message with markdown formatting.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The markdown formatted text content of the message.</p> required <code>recipients</code> <code>Sequence[str] | None</code> <p>Optional list of recipient IDs.</p> <code>None</code> <code>mentions</code> <code>list[MessageMention] | None</code> <p>Optional list of MessageMention objects for @mentions.</p> <code>None</code> <p>Returns:</p> Type Description <code>SendMessageResponse | None</code> <p>A SendMessageResponse object if successful, otherwise None.</p> Source code in <code>signal_client/core/context.py</code> <pre><code>async def send_markdown(\n    self,\n    text: str,\n    *,\n    recipients: Sequence[str] | None = None,\n    mentions: list[MessageMention] | None = None,\n) -&gt; SendMessageResponse | None:\n    \"\"\"Send a message with markdown formatting.\n\n    Args:\n        text: The markdown formatted text content of the message.\n        recipients: Optional list of recipient IDs.\n        mentions: Optional list of MessageMention objects for @mentions.\n\n    Returns:\n        A SendMessageResponse object if successful, otherwise None.\n\n    \"\"\"\n    return await self.send_text(\n        text,\n        recipients=recipients,\n        mentions=mentions,\n        text_mode=\"styled\",\n    )\n</code></pre>"},{"location":"reference/api/#signal_client.core.context.Context.send_with_preview","title":"send_with_preview  <code>async</code>","text":"<pre><code>send_with_preview(\n    url: str,\n    *,\n    message: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    recipients: Sequence[str] | None = None,\n    text_mode: Literal[\"normal\", \"styled\"] | None = None\n) -&gt; SendMessageResponse | None\n</code></pre> <p>Send a message with a link preview.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL for which to generate a preview.</p> required <code>message</code> <code>str | None</code> <p>Optional text message to accompany the link preview.</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Optional title for the link preview.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Optional description for the link preview.</p> <code>None</code> <code>recipients</code> <code>Sequence[str] | None</code> <p>Optional list of recipient IDs.</p> <code>None</code> <code>text_mode</code> <code>Literal['normal', 'styled'] | None</code> <p>'normal' for plain text, 'styled' for markdown.</p> <code>None</code> <p>Returns:</p> Type Description <code>SendMessageResponse | None</code> <p>A SendMessageResponse object if successful, otherwise None.</p> Source code in <code>signal_client/core/context.py</code> <pre><code>async def send_with_preview(  # noqa: PLR0913\n    self,\n    url: str,\n    *,\n    message: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    recipients: Sequence[str] | None = None,\n    text_mode: Literal[\"normal\", \"styled\"] | None = None,\n) -&gt; SendMessageResponse | None:\n    \"\"\"Send a message with a link preview.\n\n    Args:\n        url: The URL for which to generate a preview.\n        message: Optional text message to accompany the link preview.\n        title: Optional title for the link preview.\n        description: Optional description for the link preview.\n        recipients: Optional list of recipient IDs.\n        text_mode: 'normal' for plain text, 'styled' for markdown.\n\n    Returns:\n        A SendMessageResponse object if successful, otherwise None.\n\n    \"\"\"\n    preview = LinkPreview(\n        url=url,\n        title=title,\n        description=description,\n    )\n    return await self.send_text(\n        message or url,\n        recipients=recipients,\n        link_preview=preview,\n        text_mode=text_mode,\n    )\n</code></pre>"},{"location":"reference/api/#signal_client.core.context.Context.react","title":"react  <code>async</code>","text":"<pre><code>react(emoji: str) -&gt; None\n</code></pre> <p>Add a reaction (emoji) to the incoming message.</p> <p>Parameters:</p> Name Type Description Default <code>emoji</code> <code>str</code> <p>The emoji string to react with (e.g., \"\ud83d\udc4d\").</p> required Source code in <code>signal_client/core/context.py</code> <pre><code>async def react(self, emoji: str) -&gt; None:\n    \"\"\"Add a reaction (emoji) to the incoming message.\n\n    Args:\n        emoji: The emoji string to react with (e.g., \"\ud83d\udc4d\").\n\n    \"\"\"\n    request = ReactionRequest(\n        reaction=emoji,\n        target_author=self.message.source,\n        timestamp=self.message.timestamp,\n        recipient=self._recipient(),\n    )\n    await self.reactions.send_reaction(\n        self._phone_number,\n        request.model_dump(by_alias=True, exclude_none=True),\n    )\n</code></pre>"},{"location":"reference/api/#signal_client.core.context.Context.send_receipt","title":"send_receipt  <code>async</code>","text":"<pre><code>send_receipt(\n    target_timestamp: int,\n    *,\n    receipt_type: Literal[\"read\", \"viewed\"] = \"read\",\n    recipient: str | None = None\n) -&gt; None\n</code></pre> <p>Send a read or viewed receipt for a message.</p> <p>Parameters:</p> Name Type Description Default <code>target_timestamp</code> <code>int</code> <p>The timestamp of the message for which to send the receipt.</p> required <code>receipt_type</code> <code>Literal['read', 'viewed']</code> <p>The type of receipt to send ('read' or 'viewed'). Defaults to 'read'.</p> <code>'read'</code> <code>recipient</code> <code>str | None</code> <p>Optional recipient ID. Defaults to the sender of the incoming message.</p> <code>None</code> Source code in <code>signal_client/core/context.py</code> <pre><code>async def send_receipt(\n    self,\n    target_timestamp: int,\n    *,\n    receipt_type: Literal[\"read\", \"viewed\"] = \"read\",\n    recipient: str | None = None,\n) -&gt; None:\n    \"\"\"Send a read or viewed receipt for a message.\n\n    Args:\n        target_timestamp: The timestamp of the message for which to send\n            the receipt.\n        receipt_type: The type of receipt to send ('read' or 'viewed').\n            Defaults to 'read'.\n        recipient: Optional recipient ID. Defaults to the sender of the\n            incoming message.\n\n    \"\"\"\n    payload = ReceiptRequest(\n        recipient=recipient or self._recipient(),\n        timestamp=target_timestamp,\n        receipt_type=receipt_type,\n    )\n    await self.receipts.send_receipt(\n        self._phone_number,\n        payload.model_dump(exclude_none=True, by_alias=True),\n    )\n</code></pre>"},{"location":"reference/api/#signal_client.core.context.Context.download_attachments","title":"download_attachments  <code>async</code>","text":"<pre><code>download_attachments(\n    attachments: Sequence[AttachmentPointer] | None = None,\n    *,\n    max_total_bytes: int = DEFAULT_MAX_TOTAL_BYTES,\n    dest_dir: str | Path | None = None\n) -&gt; AsyncGenerator[list[Path], None]\n</code></pre> <p>Download attachments associated with the current message or a provided list.</p> <p>This is an asynchronous context manager that yields a list of <code>Path</code> objects pointing to the downloaded files. The files are cleaned up automatically upon exiting the context.</p> <p>Parameters:</p> Name Type Description Default <code>attachments</code> <code>Sequence[AttachmentPointer] | None</code> <p>An optional sequence of <code>AttachmentPointer</code> objects to download. If not provided, attachments from <code>self.message</code> are used.</p> <code>None</code> <code>max_total_bytes</code> <code>int</code> <p>The maximum total size (in bytes) of attachments to download. Defaults to <code>DEFAULT_MAX_TOTAL_BYTES</code>.</p> <code>DEFAULT_MAX_TOTAL_BYTES</code> <code>dest_dir</code> <code>str | Path | None</code> <p>Optional directory to save the attachments. If not provided, a temporary directory is used.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncGenerator[list[Path], None]</code> <p>A list of <code>pathlib.Path</code> objects to the downloaded attachment files.</p> Source code in <code>signal_client/core/context.py</code> <pre><code>@asynccontextmanager\nasync def download_attachments(\n    self,\n    attachments: Sequence[AttachmentPointer] | None = None,\n    *,\n    max_total_bytes: int = DEFAULT_MAX_TOTAL_BYTES,\n    dest_dir: str | Path | None = None,\n) -&gt; AsyncGenerator[list[Path], None]:\n    \"\"\"Download attachments associated with the current message or a provided list.\n\n    This is an asynchronous context manager that yields a list of `Path`\n    objects pointing to the downloaded files. The files are cleaned up\n    automatically upon exiting the context.\n\n    Args:\n        attachments: An optional sequence of `AttachmentPointer` objects\n            to download.\n            If not provided, attachments from `self.message` are used.\n        max_total_bytes: The maximum total size (in bytes) of attachments\n            to download.\n            Defaults to `DEFAULT_MAX_TOTAL_BYTES`.\n        dest_dir: Optional directory to save the attachments. If not\n            provided, a temporary directory is used.\n\n    Yields:\n        A list of `pathlib.Path` objects to the downloaded attachment files.\n\n    \"\"\"\n    pointers: list[AttachmentPointer] = []\n    if attachments is not None:\n        pointers = list(attachments)\n    elif self.message.attachments:\n        pointers = list(self.message.attachments)\n\n    downloader = (\n        self._attachment_downloader\n        if max_total_bytes == self._attachment_downloader.max_total_bytes\n        else AttachmentDownloader(self.attachments, max_total_bytes=max_total_bytes)\n    )\n    async with downloader.download(pointers, dest_dir=dest_dir) as files:\n        yield files\n</code></pre>"},{"location":"reference/api/#signal_client.core.context.Context.lock","title":"lock  <code>async</code>","text":"<pre><code>lock(resource_id: str) -&gt; AsyncGenerator[None, None]\n</code></pre> <p>Acquire a distributed lock for a specific resource.</p> <p>This is an asynchronous context manager that ensures exclusive access to a resource across multiple instances of the application.</p> <p>Parameters:</p> Name Type Description Default <code>resource_id</code> <code>str</code> <p>A unique identifier for the resource to lock.</p> required <p>Yields:</p> Type Description <code>AsyncGenerator[None, None]</code> <p>None, while the lock is held.</p> Source code in <code>signal_client/core/context.py</code> <pre><code>@asynccontextmanager\nasync def lock(self, resource_id: str) -&gt; AsyncGenerator[None, None]:\n    \"\"\"Acquire a distributed lock for a specific resource.\n\n    This is an asynchronous context manager that ensures exclusive access\n    to a resource across multiple instances of the application.\n\n    Args:\n        resource_id: A unique identifier for the resource to lock.\n\n    Yields:\n        None, while the lock is held.\n\n    \"\"\"\n    async with self._lock_manager.lock(resource_id):\n        yield\n</code></pre>"},{"location":"reference/api/#signal_client.core.context.Context.show_typing","title":"show_typing  <code>async</code>","text":"<pre><code>show_typing() -&gt; None\n</code></pre> <p>Send a typing indicator to the sender of the incoming message.</p> Source code in <code>signal_client/core/context.py</code> <pre><code>async def show_typing(self) -&gt; None:\n    \"\"\"Send a typing indicator to the sender of the incoming message.\"\"\"\n    request = TypingIndicatorRequest(recipient=self._recipient())\n    await self.messages.set_typing_indicator(\n        self._phone_number, request.model_dump(exclude_none=True, by_alias=True)\n    )\n</code></pre>"},{"location":"reference/api/#signal_client.core.context.Context.hide_typing","title":"hide_typing  <code>async</code>","text":"<pre><code>hide_typing() -&gt; None\n</code></pre> <p>Hide the typing indicator from the sender of the incoming message.</p> Source code in <code>signal_client/core/context.py</code> <pre><code>async def hide_typing(self) -&gt; None:\n    \"\"\"Hide the typing indicator from the sender of the incoming message.\"\"\"\n    request = TypingIndicatorRequest(recipient=self._recipient())\n    await self.messages.unset_typing_indicator(\n        self._phone_number, request.model_dump(exclude_none=True, by_alias=True)\n    )\n</code></pre>"},{"location":"reference/api/#signal_client.core.command.Command.__init__","title":"__init__","text":"<pre><code>__init__(\n    triggers: list[str | Pattern],\n    whitelisted: list[str] | None = None,\n    *,\n    case_sensitive: bool = False,\n    metadata: CommandMetadata | None = None\n) -&gt; None\n</code></pre> <p>Initialize a Command instance.</p> <p>Parameters:</p> Name Type Description Default <code>triggers</code> <code>list[str | Pattern]</code> <p>A list of strings or regular expressions that will       trigger this command.</p> required <code>whitelisted</code> <code>list[str] | None</code> <p>An optional list of sender IDs (phone numbers or group IDs)          that are allowed to execute this command. If empty or None,          all senders are allowed.</p> <code>None</code> <code>case_sensitive</code> <code>bool</code> <p>If True, string triggers will be matched case-sensitively.             Defaults to False.</p> <code>False</code> <code>metadata</code> <code>CommandMetadata | None</code> <p>Optional CommandMetadata to provide name, description, and usage.</p> <code>None</code> Source code in <code>signal_client/core/command.py</code> <pre><code>def __init__(\n    self,\n    triggers: list[str | re.Pattern],\n    whitelisted: list[str] | None = None,\n    *,\n    case_sensitive: bool = False,\n    metadata: CommandMetadata | None = None,\n) -&gt; None:\n    \"\"\"Initialize a Command instance.\n\n    Args:\n        triggers: A list of strings or regular expressions that will\n                  trigger this command.\n        whitelisted: An optional list of sender IDs (phone numbers or group IDs)\n                     that are allowed to execute this command. If empty or None,\n                     all senders are allowed.\n        case_sensitive: If True, string triggers will be matched case-sensitively.\n                        Defaults to False.\n        metadata: Optional CommandMetadata to provide name, description, and usage.\n\n    \"\"\"\n    self.triggers = triggers\n    self.whitelisted = whitelisted or []\n    self.case_sensitive = case_sensitive\n    meta = metadata or CommandMetadata()\n    self.name = meta.name\n    self.description = meta.description\n    self.usage = meta.usage\n    self.handle: Callable[[Context], Awaitable[None]] | None = None\n</code></pre>"},{"location":"reference/api/#signal_client.core.command.Command.with_handler","title":"with_handler","text":"<pre><code>with_handler(\n    handler: Callable[[Context], Awaitable[None]],\n) -&gt; Command\n</code></pre> <p>Assign a handler function to this command.</p> <p>If name or description are not already set, they will be inferred from the handler function's name and docstring.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[Context], Awaitable[None]]</code> <p>The asynchronous function that will be executed when      this command is triggered. It must accept a Context object.</p> required <p>Returns:</p> Type Description <code>Command</code> <p>The Command instance with the handler assigned.</p> Source code in <code>signal_client/core/command.py</code> <pre><code>def with_handler(self, handler: Callable[[Context], Awaitable[None]]) -&gt; Command:\n    \"\"\"Assign a handler function to this command.\n\n    If name or description are not already set, they will be inferred\n    from the handler function's name and docstring.\n\n    Args:\n        handler: The asynchronous function that will be executed when\n                 this command is triggered. It must accept a Context object.\n\n    Returns:\n        The Command instance with the handler assigned.\n\n    \"\"\"\n    self.handle = handler\n    if self.name is None:\n        self.name = handler.__name__\n    if self.description is None:\n        doc = inspect.getdoc(handler)\n        self.description = doc.strip() if doc else None\n    return self\n</code></pre>"},{"location":"reference/api/#signal_client.core.command.Command.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(context: Context) -&gt; None\n</code></pre> <p>Execute the command's handler function.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The Context object containing message details and API clients.</p> required <p>Raises:</p> Type Description <code>CommandError</code> <p>If no handler has been assigned to the command.</p> Source code in <code>signal_client/core/command.py</code> <pre><code>async def __call__(self, context: Context) -&gt; None:\n    \"\"\"Execute the command's handler function.\n\n    Args:\n        context: The Context object containing message details and API clients.\n\n    Raises:\n        CommandError: If no handler has been assigned to the command.\n\n    \"\"\"\n    if self.handle is None:\n        message = _COMMAND_HANDLER_NOT_SET\n        raise CommandError(message)\n    await self.handle(context)\n</code></pre>"},{"location":"reference/api/#settings","title":"Settings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Single, explicit configuration surface for the Signal client.</p> <p>Settings are loaded from environment variables and an optional .env file. All settings can be overridden via constructor arguments.</p> Source code in <code>signal_client/core/config.py</code> <pre><code>class Settings(BaseSettings):\n    \"\"\"Single, explicit configuration surface for the Signal client.\n\n    Settings are loaded from environment variables and an optional .env file.\n    All settings can be overridden via constructor arguments.\n    \"\"\"\n\n    phone_number: str = Field(..., validation_alias=\"SIGNAL_PHONE_NUMBER\")\n    signal_service: str = Field(..., validation_alias=\"SIGNAL_SERVICE_URL\")\n    base_url: str = Field(..., validation_alias=\"SIGNAL_API_URL\")\n\n    api_retries: int = Field(\n        3, description=\"Number of times to retry API requests on transient errors.\"\n    )\n    api_backoff_factor: float = Field(\n        0.5, description=\"Factor for exponential backoff between API retries.\"\n    )\n    api_timeout: int = Field(\n        30, description=\"Default timeout (in seconds) for API requests.\"\n    )\n    api_auth_token: str | None = Field(\n        default=None,\n        validation_alias=\"SIGNAL_API_TOKEN\",\n        description=\"API authentication token.\",\n    )\n    api_auth_scheme: str = Field(\n        \"Bearer\",\n        description=\"Authentication scheme (e.g., 'Bearer') for the API token.\",\n    )\n    api_default_headers: dict[str, str] = Field(\n        default_factory=dict,\n        description=\"Default headers to send with all API requests.\",\n    )\n    api_endpoint_timeouts: dict[str, float] = Field(\n        default_factory=dict,\n        description=\"Per-endpoint timeout overrides (e.g., {'/messages': 60}).\",\n    )\n    api_idempotency_header: str = Field(\n        \"Idempotency-Key\", description=\"Header name for idempotency keys.\"\n    )\n\n    queue_size: int = Field(\n        1000, description=\"Maximum number of messages to queue for processing.\"\n    )\n    worker_pool_size: int = Field(\n        4, description=\"Number of worker tasks to process messages concurrently.\"\n    )\n    worker_shard_count: int = Field(\n        0,\n        description=\"Number of shards for worker pool. \"\n        \"Defaults to worker_pool_size if 0.\",\n    )\n    queue_put_timeout: float = Field(\n        1.0, description=\"Timeout (in seconds) for putting messages into the queue.\"\n    )\n    queue_drop_oldest_on_timeout: bool = Field(\n        default=True,\n        description=\"If True, drop oldest message if queue is full and put times out.\",\n    )\n    durable_queue_enabled: bool = Field(\n        default=False, description=\"Enable persistent queueing for messages.\"\n    )\n    durable_queue_max_length: int = Field(\n        10000, description=\"Maximum length of the durable queue.\"\n    )\n    ingest_checkpoint_window: int = Field(\n        5000, description=\"Number of messages after which to save ingest checkpoint.\"\n    )\n    ingest_queue_name: str = Field(\n        \"signal_client_ingest\",\n        description=\"Name of the ingest queue in persistent storage.\",\n    )\n    ingest_checkpoint_key: str = Field(\n        \"signal_client_ingest_checkpoint\",\n        description=\"Key for storing ingest checkpoint in persistent storage.\",\n    )\n    ingest_pause_seconds: float = Field(\n        1.0, description=\"Default duration (in seconds) to pause message ingestion.\"\n    )\n    distributed_locks_enabled: bool = Field(\n        default=False, description=\"Enable distributed locking for worker coordination.\"\n    )\n    distributed_lock_timeout: int = Field(\n        30, description=\"Timeout (in seconds) for acquiring distributed locks.\"\n    )\n\n    rate_limit: int = Field(\n        50, description=\"Maximum number of API requests per rate_limit_period.\"\n    )\n    rate_limit_period: int = Field(\n        1, description=\"Time window (in seconds) for rate limiting.\"\n    )\n    websocket_path: str | None = Field(\n        default=None,\n        validation_alias=\"SIGNAL_WS_PATH\",\n        description=\"WebSocket path for Signal service.\",\n    )\n\n    circuit_breaker_failure_threshold: int = Field(\n        5, description=\"Number of failures before circuit opens.\"\n    )\n    circuit_breaker_reset_timeout: int = Field(\n        30, description=\"Time (in seconds) before a half-open state is attempted.\"\n    )\n    circuit_breaker_failure_rate_threshold: float = Field(\n        0.5, description=\"Failure rate threshold (0.0-1.0) to open the circuit.\"\n    )\n    circuit_breaker_min_requests_for_rate_calc: int = Field(\n        10, description=\"Minimum requests needed to calculate failure rate.\"\n    )\n\n    storage_type: str = Field(\n        \"memory\", description=\"Type of storage backend: 'memory', 'sqlite', or 'redis'.\"\n    )\n    redis_host: str = Field(\n        \"localhost\", description=\"Redis host for 'redis' storage type.\"\n    )\n    redis_port: int = Field(6379, description=\"Redis port for 'redis' storage type.\")\n    sqlite_database: str = Field(\n        \"signal_client.db\",\n        description=\"SQLite database file for 'sqlite' storage type.\",\n    )\n\n    dlq_name: str = Field(\n        \"signal_client_dlq\",\n        description=\"Name of the Dead Letter Queue in persistent storage.\",\n    )\n    dlq_max_retries: int = Field(\n        5, description=\"Maximum number of retries for messages in the DLQ.\"\n    )\n\n    log_redaction_enabled: bool = Field(\n        default=True, description=\"Enable or disable PII redaction in logs.\"\n    )\n\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        populate_by_name=True,\n        extra=\"ignore\",\n        case_sensitive=False,\n    )\n\n    @model_validator(mode=\"after\")\n    def validate_storage(self) -&gt; Self:\n        \"\"\"Validate storage-related settings based on the chosen storage_type.\n\n        Ensures that required fields for 'redis' and 'sqlite' storage are provided\n        and that numeric fields have valid positive values.\n\n        Raises:\n            ValueError: If storage configuration is invalid.\n\n        Returns:\n            The validated Settings instance.\n\n        \"\"\"\n        self._validate_storage_type()\n        self._validate_queue_limits()\n        self._normalize_worker_shards()\n        self._validate_endpoint_timeouts()\n        self._ensure_idempotency_header()\n        return self\n\n    def _validate_storage_type(self) -&gt; None:\n        storage_type = self.storage_type.lower()\n        validators = {\n            \"redis\": self._validate_redis_storage,\n            \"sqlite\": self._validate_sqlite_storage,\n            \"memory\": lambda: None,\n        }\n        validator = validators.get(storage_type)\n        if validator is None:\n            message = f\"Unsupported storage_type '{self.storage_type}'.\"\n            raise ValueError(message)\n        validator()\n\n    def _validate_redis_storage(self) -&gt; None:\n        if not self.redis_host:\n            message = \"Redis storage requires 'redis_host'.\"\n            raise ValueError(message)\n        if self.redis_port is None:\n            message = \"Redis storage requires 'redis_port'.\"\n            raise ValueError(message)\n        if isinstance(self.redis_port, int) and self.redis_port &lt;= 0:\n            message = \"'redis_port' must be a positive integer.\"\n            raise ValueError(message)\n\n    def _validate_sqlite_storage(self) -&gt; None:\n        if not self.sqlite_database:\n            message = \"SQLite storage requires 'sqlite_database'.\"\n            raise ValueError(message)\n\n    def _validate_queue_limits(self) -&gt; None:\n        if self.durable_queue_max_length &lt;= 0:\n            message = \"'durable_queue_max_length' must be positive.\"\n            raise ValueError(message)\n        if self.ingest_checkpoint_window &lt;= 0:\n            message = \"'ingest_checkpoint_window' must be positive.\"\n            raise ValueError(message)\n        if self.ingest_pause_seconds &lt; 0:\n            message = \"'ingest_pause_seconds' must be non-negative.\"\n            raise ValueError(message)\n        if self.distributed_lock_timeout &lt;= 0:\n            message = \"'distributed_lock_timeout' must be positive.\"\n            raise ValueError(message)\n\n    def _normalize_worker_shards(self) -&gt; None:\n        if (\n            self.worker_shard_count &lt;= 0\n            or self.worker_shard_count &gt; self.worker_pool_size\n        ):\n            self.worker_shard_count = self.worker_pool_size\n\n    def _validate_endpoint_timeouts(self) -&gt; None:\n        for path, timeout in self.api_endpoint_timeouts.items():\n            if timeout is None or float(timeout) &lt;= 0:\n                message = (\n                    f\"'api_endpoint_timeouts' entry for '{path}' must be positive.\"\n                )\n                raise ValueError(message)\n\n    def _ensure_idempotency_header(self) -&gt; None:\n        if not self.api_idempotency_header:\n            message = \"'api_idempotency_header' cannot be empty.\"\n            raise ValueError(message)\n\n    @classmethod\n    def from_sources(cls: type[Self], config: dict[str, Any] | None = None) -&gt; Self:\n        \"\"\"Load settings from environment variables and an optional dictionary.\n\n        Args:\n            config: An optional dictionary to override environment-loaded settings.\n\n        Raises:\n            ConfigurationError: If any required settings are missing or invalid.\n\n        Returns:\n            A validated Settings instance.\n\n        \"\"\"\n        try:\n            env_payload: dict[str, Any] = {}\n            try:\n                env_payload = cls().model_dump()  # type: ignore[call-arg]\n            except ValidationError:\n                env_payload = {}\n\n            payload: dict[str, Any] = (\n                env_payload if config is None else {**env_payload, **config}\n            )\n            with _without_required_env():\n                settings = cls.model_validate(payload)\n            cls._validate_required_fields(settings)\n        except ValidationError as validation_error:\n            raise cls._wrap_validation_error(validation_error) from validation_error\n        else:\n            return settings\n\n    @classmethod\n    def _wrap_validation_error(cls, error: ValidationError) -&gt; ConfigurationError:\n        \"\"\"Wrap a Pydantic ValidationError in a custom ConfigurationError.\n\n        Args:\n            error: The original Pydantic ValidationError.\n\n        Returns:\n            A ConfigurationError with a more user-friendly message.\n\n        \"\"\"\n\n        def _error_field(err: Mapping[str, object]) -&gt; str:\n            loc = err.get(\"loc\")\n            if not isinstance(loc, (list, tuple)):\n                return \"\"\n            return str(loc[-1]) if loc else \"\"\n\n        missing = cls._missing_fields(error)\n        errors = error.errors(include_url=False)\n        fields = {_error_field(err) for err in errors if _error_field(err)}\n        invalid_fields = sorted(fields - {field.split(\"/\")[-1] for field in missing})\n        invalid_errors = [err for err in errors if _error_field(err) in invalid_fields]\n\n        if missing and invalid_fields:\n            missing_list = \", \".join(sorted(missing))\n            invalid_list = \", \".join(invalid_fields)\n            first_error = (\n                invalid_errors[0][\"msg\"] if invalid_errors else errors[0][\"msg\"]\n            )\n            message = (\n                f\"Invalid configuration overrides. Missing: {missing_list}. \"\n                f\"Invalid: {invalid_list} ({first_error}).\"\n            )\n            return ConfigurationError(message)\n\n        if missing:\n            missing_list = \", \".join(sorted(missing))\n            message = f\"Missing required configuration values: {missing_list}.\"\n            return ConfigurationError(message)\n\n        first_error = errors[0][\"msg\"]\n        field_list = \", \".join(sorted(fields)) if fields else \"configuration\"\n        message = f\"Invalid configuration for {field_list}: {first_error}.\"\n        return ConfigurationError(message)\n\n    @classmethod\n    def _missing_fields(cls, error: ValidationError) -&gt; set[str]:\n        \"\"\"Extract missing field names from a Pydantic ValidationError.\n\n        Args:\n            error: The Pydantic ValidationError instance.\n\n        Returns:\n            A set of strings representing the names of missing fields.\n\n        \"\"\"\n        missing: set[str] = set()\n        for err in error.errors(include_url=False):\n            if err.get(\"type\") not in {\"missing\", \"value_error.missing\"}:\n                continue\n            loc = err.get(\"loc\")\n            if not loc:\n                continue\n            field_name = str(loc[-1])\n            alias = cls._env_alias_for_field(field_name)\n            missing.add(alias or field_name)\n        return missing\n\n    @classmethod\n    def _env_alias_for_field(cls, field_name: str) -&gt; str | None:\n        \"\"\"Get the environment variable alias for a given field name.\n\n        Args:\n            field_name: The name of the setting field.\n\n        Returns:\n            The environment variable alias if found, otherwise None.\n\n        \"\"\"\n        field = cls.model_fields.get(field_name)\n        if not field:\n            return None\n        alias = field.validation_alias\n        if not alias:\n            return None\n        return (\n            str(alias)\n            if not isinstance(alias, tuple)\n            else \"/\".join(str(item) for item in alias)\n        )\n\n    @classmethod\n    def _validate_required_fields(cls, settings: Self) -&gt; None:\n        \"\"\"Validate that essential required fields are present.\n\n        Args:\n            settings: The Settings instance to validate.\n\n        Raises:\n            ConfigurationError: If any essential required fields are missing.\n\n        \"\"\"\n        missing = [\n            field\n            for field in (\"phone_number\", \"signal_service\", \"base_url\")\n            if not getattr(settings, field)\n        ]\n        if missing:\n            missing_list = \", \".join(missing)\n            message = f\"Missing required configuration values: {missing_list}.\"\n            raise ConfigurationError(message)\n</code></pre>"},{"location":"reference/api/#signal_client.core.config.Settings.validate_storage","title":"validate_storage","text":"<pre><code>validate_storage() -&gt; Self\n</code></pre> <p>Validate storage-related settings based on the chosen storage_type.</p> <p>Ensures that required fields for 'redis' and 'sqlite' storage are provided and that numeric fields have valid positive values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If storage configuration is invalid.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The validated Settings instance.</p> Source code in <code>signal_client/core/config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_storage(self) -&gt; Self:\n    \"\"\"Validate storage-related settings based on the chosen storage_type.\n\n    Ensures that required fields for 'redis' and 'sqlite' storage are provided\n    and that numeric fields have valid positive values.\n\n    Raises:\n        ValueError: If storage configuration is invalid.\n\n    Returns:\n        The validated Settings instance.\n\n    \"\"\"\n    self._validate_storage_type()\n    self._validate_queue_limits()\n    self._normalize_worker_shards()\n    self._validate_endpoint_timeouts()\n    self._ensure_idempotency_header()\n    return self\n</code></pre>"},{"location":"reference/api/#signal_client.core.config.Settings.from_sources","title":"from_sources  <code>classmethod</code>","text":"<pre><code>from_sources(config: dict[str, Any] | None = None) -&gt; Self\n</code></pre> <p>Load settings from environment variables and an optional dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | None</code> <p>An optional dictionary to override environment-loaded settings.</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any required settings are missing or invalid.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A validated Settings instance.</p> Source code in <code>signal_client/core/config.py</code> <pre><code>@classmethod\ndef from_sources(cls: type[Self], config: dict[str, Any] | None = None) -&gt; Self:\n    \"\"\"Load settings from environment variables and an optional dictionary.\n\n    Args:\n        config: An optional dictionary to override environment-loaded settings.\n\n    Raises:\n        ConfigurationError: If any required settings are missing or invalid.\n\n    Returns:\n        A validated Settings instance.\n\n    \"\"\"\n    try:\n        env_payload: dict[str, Any] = {}\n        try:\n            env_payload = cls().model_dump()  # type: ignore[call-arg]\n        except ValidationError:\n            env_payload = {}\n\n        payload: dict[str, Any] = (\n            env_payload if config is None else {**env_payload, **config}\n        )\n        with _without_required_env():\n            settings = cls.model_validate(payload)\n        cls._validate_required_fields(settings)\n    except ValidationError as validation_error:\n        raise cls._wrap_validation_error(validation_error) from validation_error\n    else:\n        return settings\n</code></pre>"},{"location":"reference/api/#observability","title":"Observability","text":""},{"location":"reference/api/#signal_client.observability.health_server.start_health_server","title":"signal_client.observability.health_server.start_health_server  <code>async</code>","text":"<pre><code>start_health_server(\n    application: Application,\n    *,\n    host: str = \"127.0.0.1\",\n    port: int = 8081\n) -&gt; HealthServer\n</code></pre> <p>Create and start a HealthServer for the given application.</p> Source code in <code>signal_client/observability/health_server.py</code> <pre><code>async def start_health_server(\n    application: Application,\n    *,\n    host: str = \"127.0.0.1\",\n    port: int = 8081,\n) -&gt; HealthServer:\n    \"\"\"Create and start a HealthServer for the given application.\"\"\"\n    server = HealthServer(application, host=host, port=port)\n    await server.start()\n    return server\n</code></pre>"},{"location":"reference/api/#signal_client.observability.metrics_server.start_metrics_server","title":"signal_client.observability.metrics_server.start_metrics_server","text":"<pre><code>start_metrics_server(\n    port: int = 8000,\n    addr: str = \"127.0.0.1\",\n    *,\n    registry: CollectorRegistry | None = None\n) -&gt; object\n</code></pre> <p>Start an HTTP server that exposes Prometheus metrics at <code>/</code>.</p> <p>Returns the server object so callers can stop it if desired.</p> Source code in <code>signal_client/observability/metrics.py</code> <pre><code>def start_metrics_server(\n    port: int = 8000,\n    addr: str = \"127.0.0.1\",\n    *,\n    registry: CollectorRegistry | None = None,\n) -&gt; object:\n    \"\"\"Start an HTTP server that exposes Prometheus metrics at `/`.\n\n    Returns the server object so callers can stop it if desired.\n    \"\"\"\n    return start_http_server(port, addr=addr, registry=registry or REGISTRY)\n</code></pre>"},{"location":"reference/api/#signal_client.observability.logging.ensure_structlog_configured","title":"signal_client.observability.logging.ensure_structlog_configured","text":"<pre><code>ensure_structlog_configured(\n    *,\n    json_output: bool = False,\n    redaction_enabled: bool = True\n) -&gt; None\n</code></pre> <p>Idempotently configure structlog unless already configured externally.</p> Source code in <code>signal_client/observability/logging.py</code> <pre><code>def ensure_structlog_configured(\n    *,\n    json_output: bool = False,\n    redaction_enabled: bool = True,\n) -&gt; None:\n    \"\"\"Idempotently configure structlog unless already configured externally.\"\"\"\n    _StructlogGuard.ensure_configured(\n        json_output=json_output,\n        redaction_enabled=redaction_enabled,\n    )\n</code></pre>"},{"location":"reference/api/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Missing members in the reference? Run <code>poetry run mkdocs build --strict</code> to surface mkdocstrings import errors (often missing deps).</li> <li>Import path errors: prefer <code>signal_client.&lt;module&gt;</code> paths shown above; avoid private modules not exported in <code>__all__</code>.</li> </ul>"},{"location":"reference/api/#next-steps","title":"Next steps","text":"<ul> <li>Use the reference alongside Examples to map API calls to runnable scripts.</li> <li>See Advanced usage for middleware and resiliency tuning using these APIs.</li> </ul>"},{"location":"reference/api/#exceptions","title":"Exceptions","text":""},{"location":"reference/api/#signal_client.core.exceptions","title":"signal_client.core.exceptions","text":"<p>Custom exceptions for the Signal client.</p>"},{"location":"reference/api/#signal_client.core.exceptions.AuthenticationError","title":"AuthenticationError","text":"<p>               Bases: <code>SignalAPIError</code></p> <p>Raised for authentication failures (HTTP status code 401 Unauthorized).</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>class AuthenticationError(SignalAPIError):\n    \"\"\"Raised for authentication failures (HTTP status code 401 Unauthorized).\"\"\"\n\n    def __init__(self, message: str, status_code: int | None = 401) -&gt; None:\n        \"\"\"Initialize an authentication error.\"\"\"\n        super().__init__(message, status_code)\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.AuthenticationError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str, status_code: int | None = 401\n) -&gt; None\n</code></pre> <p>Initialize an authentication error.</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>def __init__(self, message: str, status_code: int | None = 401) -&gt; None:\n    \"\"\"Initialize an authentication error.\"\"\"\n    super().__init__(message, status_code)\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.ConfigurationError","title":"ConfigurationError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when there is an issue with the application's configuration.</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>class ConfigurationError(Exception):\n    \"\"\"Raised when there is an issue with the application's configuration.\"\"\"\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.GroupNotFoundError","title":"GroupNotFoundError","text":"<p>               Bases: <code>SignalAPIError</code></p> <p>Raised when a requested group is not found (HTTP status 404.</p> <p>For group-related operations).</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>class GroupNotFoundError(SignalAPIError):\n    \"\"\"Raised when a requested group is not found (HTTP status 404.\n\n    For group-related operations).\n    \"\"\"\n\n    def __init__(self, message: str, status_code: int | None = 404) -&gt; None:\n        \"\"\"Initialize a group-not-found error.\"\"\"\n        super().__init__(message, status_code)\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.GroupNotFoundError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str, status_code: int | None = 404\n) -&gt; None\n</code></pre> <p>Initialize a group-not-found error.</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>def __init__(self, message: str, status_code: int | None = 404) -&gt; None:\n    \"\"\"Initialize a group-not-found error.\"\"\"\n    super().__init__(message, status_code)\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.InvalidRecipientError","title":"InvalidRecipientError","text":"<p>               Bases: <code>SignalAPIError</code></p> <p>Raised when a message cannot be sent due to an invalid recipient.</p> <p>Applies to HTTP status 404 on send operations.</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>class InvalidRecipientError(SignalAPIError):\n    \"\"\"Raised when a message cannot be sent due to an invalid recipient.\n\n    Applies to HTTP status 404 on send operations.\n    \"\"\"\n\n    def __init__(self, message: str, status_code: int | None = 404) -&gt; None:\n        \"\"\"Initialize an invalid recipient error.\"\"\"\n        super().__init__(message, status_code)\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.InvalidRecipientError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str, status_code: int | None = 404\n) -&gt; None\n</code></pre> <p>Initialize an invalid recipient error.</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>def __init__(self, message: str, status_code: int | None = 404) -&gt; None:\n    \"\"\"Initialize an invalid recipient error.\"\"\"\n    super().__init__(message, status_code)\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.RateLimitError","title":"RateLimitError","text":"<p>               Bases: <code>SignalAPIError</code></p> <p>Raised when the API rate limit is exceeded (HTTP status codes 413 or 429).</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>class RateLimitError(SignalAPIError):\n    \"\"\"Raised when the API rate limit is exceeded (HTTP status codes 413 or 429).\"\"\"\n\n    def __init__(self, message: str, status_code: int | None = 429) -&gt; None:\n        \"\"\"Initialize a rate limit error.\"\"\"\n        super().__init__(message, status_code)\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.RateLimitError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str, status_code: int | None = 429\n) -&gt; None\n</code></pre> <p>Initialize a rate limit error.</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>def __init__(self, message: str, status_code: int | None = 429) -&gt; None:\n    \"\"\"Initialize a rate limit error.\"\"\"\n    super().__init__(message, status_code)\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.ServerError","title":"ServerError","text":"<p>               Bases: <code>SignalAPIError</code></p> <p>Raised for server-side errors (HTTP status codes 5xx).</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>class ServerError(SignalAPIError):\n    \"\"\"Raised for server-side errors (HTTP status codes 5xx).\"\"\"\n\n    def __init__(self, message: str, status_code: int | None = 500) -&gt; None:\n        \"\"\"Initialize a server error.\"\"\"\n        super().__init__(message, status_code)\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.ServerError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str, status_code: int | None = 500\n) -&gt; None\n</code></pre> <p>Initialize a server error.</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>def __init__(self, message: str, status_code: int | None = 500) -&gt; None:\n    \"\"\"Initialize a server error.\"\"\"\n    super().__init__(message, status_code)\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.SignalAPIError","title":"SignalAPIError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all API-related errors.</p> <p>This exception is raised for general API errors that do not fall into more specific categories (e.g., unexpected status codes).</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>class SignalAPIError(Exception):\n    \"\"\"Base exception for all API-related errors.\n\n    This exception is raised for general API errors that do not fall into\n    more specific categories (e.g., unexpected status codes).\n    \"\"\"\n\n    def __init__(self, message: str, status_code: int | None = None) -&gt; None:\n        \"\"\"Store an API error message and optional status code.\"\"\"\n        super().__init__(message)\n        self.status_code = status_code\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.SignalAPIError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str, status_code: int | None = None\n) -&gt; None\n</code></pre> <p>Store an API error message and optional status code.</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>def __init__(self, message: str, status_code: int | None = None) -&gt; None:\n    \"\"\"Store an API error message and optional status code.\"\"\"\n    super().__init__(message)\n    self.status_code = status_code\n</code></pre>"},{"location":"reference/api/#signal_client.core.exceptions.UnsupportedMessageError","title":"UnsupportedMessageError","text":"<p>               Bases: <code>SignalClientError</code></p> <p>Custom exception for unsupported message types encountered during processing.</p> Source code in <code>signal_client/core/exceptions.py</code> <pre><code>class UnsupportedMessageError(SignalClientError):\n    \"\"\"Custom exception for unsupported message types encountered during processing.\"\"\"\n</code></pre>"}]}